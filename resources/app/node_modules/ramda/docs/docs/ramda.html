<!DOCTYPE html>

<html>
<head>
  <title>ramda.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="ramda.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>ramda.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <pre><code>ramda.js <span class="hljs-number">0.2</span><span class="hljs-number">.2</span>
https:<span class="hljs-comment">//github.com/CrossEye/ramda</span>
(c) <span class="hljs-number">2013</span>-<span class="hljs-number">2014</span> Scott Sauyet and Michael Hurley
Ramda may be freely distributed under the MIT license.
</code></pre>
            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h2 id="ramda">Ramda</h2>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>A practical functional library for Javascript programmers.  Ramda is a collection of tools to make it easier to
use Javascript as a functional programming language.  (The name is just a silly play on <code>lambda</code>.)</p>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h2 id="basic-setup">Basic Setup</h2>

            </div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Uses a technique from the <a href="https://github.com/umdjs/umd/blob/master/returnExports.js">Universal Module Definition</a> to wrap this up for use in Node.js or in the browser,
with or without an AMD-style loader.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(root, factory)</span> </span>{<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exports === <span class="hljs-string">'object'</span>) {<span class="hljs-built_in">module</span>.exports = factory(root);} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">'function'</span> &amp;&amp; define.amd) {define(factory);} <span class="hljs-keyword">else</span> {root.ramda = factory(root);}}(<span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(global)</span> </span>{
<span class="hljs-pi">
    "use strict"</span>;
    <span class="hljs-keyword">return</span>  (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>This object is what is actually returned, with all the exposed functions attached as properties.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span>
        <span class="hljs-keyword">var</span> R = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h2 id="internal-functions-and-properties">Internal Functions and Properties</h2>

            </div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * A reference to the `undefined` value.
         *
         * Note that this is defined as the result of calling an empty function because JSHint
         * complains about these constructs:
         *
         * var undef = void 0;
         * var undef = undefined;
         */</span>
        <span class="hljs-keyword">var</span> undef = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{})();

        <span class="hljs-comment">/**
         * Creates an alias for a public function.
         *
         * @private
         * @category Internal
         * @param {string} oldName The name of the public function to alias.
         * @return {Function} A function decorated with the `is`, `are`, and `and` methods. Create
         * an alias for the `oldName function by invoking any of these methods an passing it a
         * string with the `newName` parameter.
         * @example
         *
         * // Create an alias for `each` named `forEach`
         * aliasFor('each').is('forEach');
         */</span>
        <span class="hljs-keyword">var</span> aliasFor = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(oldName)</span> </span>{
            <span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(newName)</span> </span>{
                R[newName] = R[oldName];
                <span class="hljs-keyword">return</span> fn;
            };
            fn.is = fn.are = fn.and = fn;
            <span class="hljs-keyword">return</span> fn;
        };

        <span class="hljs-comment">/**
         * An optimized, private array `slice` implementation.
         *
         * @private
         * @category Internal
         * @param {Arguments|Array} args The array or arguments object to consider.
         * @param {number} [from=0] The array index to slice from, inclusive.
         * @param {number} [to=args.length] The array index to slice to, exclusive.
         * @return {Array} A new, sliced array.
         * @example
         *
         * _slice([1, 2, 3, 4, 5], 1, 3); //=&gt; [2, 3]
         *
         * var firstThreeArgs = function(a, b, c, d) {
         *   return _slice(arguments, 0, 3);
         * };
         * firstThreeArgs(1, 2, 3, 4); //=&gt; [1, 2, 3]
         */</span>
        <span class="hljs-keyword">var</span> _slice = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(args, from, to)</span> </span>{
            from = (<span class="hljs-keyword">typeof</span> from === <span class="hljs-string">"number"</span> ) ? from : <span class="hljs-number">0</span>;
            to = (<span class="hljs-keyword">typeof</span> to === <span class="hljs-string">"number"</span> ) ? to : args.length;
            <span class="hljs-keyword">var</span> length = to - from,
                arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(length),
                i = -<span class="hljs-number">1</span>;

            <span class="hljs-keyword">while</span> (++i &lt; length) {
                arr[i] = args[from + i];
            }
            <span class="hljs-keyword">return</span> arr;
        };

        <span class="hljs-comment">/**
         * Private `concat` function to merge two array-like objects.
         *
         * @private
         * @category Internal
         * @param {Array|Arguments} [set1=[]] An array-like object.
         * @param {Array|Arguments} [set2=[]] An array-like object.
         * @return {Array} A new, merged array.
         * @example
         *
         * concat([4, 5, 6], [1, 2, 3]); //=&gt; [4, 5, 6, 1, 2, 3]
         */</span>
        <span class="hljs-keyword">var</span> concat = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(set1, set2)</span> </span>{
            set1 = set1 || [];
            set2 = set2 || [];
            <span class="hljs-keyword">var</span> length1 = set1.length,
                length2 = set2.length,
                result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(length1 + length2);

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length1; i++) {
                result[i] = set1[i];
            }
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length2; i++) {
                result[i + length1] = set2[i];
            }
            <span class="hljs-keyword">return</span> result;
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Private reference to toString function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> toString = <span class="hljs-built_in">Object</span>.prototype.toString;

        <span class="hljs-comment">/**
         * Tests whether or not an object is an array.
         *
         * @private
         * @category Internal
         * @param {*} val The object to test.
         * @return {boolean} `true` if `val` is an array, `false` otherwise.
         * @example
         *
         * isArray([]); //=&gt; true
         * isArray(true); //=&gt; false
         * isArray({}); //=&gt; false
         */</span>
        <span class="hljs-keyword">var</span> isArray = <span class="hljs-built_in">Array</span>.isArray || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(val)</span> </span>{
            <span class="hljs-keyword">return</span> val &amp;&amp; val.length &gt;= <span class="hljs-number">0</span> &amp;&amp; toString.call(val) === <span class="hljs-string">"[object Array]"</span>;
        };

        <span class="hljs-comment">/**
         * Creates a new version of `fn` that, when invoked, will return either:
         * - A new function ready to accept one or more of `fn`'s remaining arguments, if all of
         * `fn`'s expected arguments have not yet been provided
         * - `fn`'s result if all of its expected arguments have been provided
         *
         * Optionally, you may provide an arity for the returned function.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} fn The function to curry.
         * @param {number} [fnArity=fn.length] An optional arity for the returned function.
         * @return {Function} A new, curried function.
         * @example
         *
         * var addFourNumbers = function(a, b, c, d) {
         *   return a + b + c + d;
         * };
         *
         * var curriedAddFourNumbers = curry(addFourNumbers);
         * var f = curriedAddFourNumbers(1, 2);
         * var g = f(3);
         * g(4);//=&gt; 10
         */</span>
        <span class="hljs-keyword">var</span> curry = R.curry = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn, fnArity)</span> </span>{
            fnArity = <span class="hljs-keyword">typeof</span> fnArity === <span class="hljs-string">"number"</span> ? fnArity : fn.length;
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recurry</span><span class="hljs-params">(args)</span> </span>{
                <span class="hljs-keyword">return</span> arity(<span class="hljs-built_in">Math</span>.max(fnArity - (args &amp;&amp; args.length || <span class="hljs-number">0</span>), <span class="hljs-number">0</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">0</span>) { <span class="hljs-keyword">throw</span> NO_ARGS_EXCEPTION; }
                    <span class="hljs-keyword">var</span> newArgs = concat(args, <span class="hljs-built_in">arguments</span>);
                    <span class="hljs-keyword">if</span> (newArgs.length &gt;= fnArity) {
                        <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, newArgs);
                    }
                    <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">return</span> recurry(newArgs);
                    }
                });
            }

            <span class="hljs-keyword">return</span> recurry([]);
        };

        <span class="hljs-keyword">var</span> NO_ARGS_EXCEPTION = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Function called with no arguments'</span>);

        <span class="hljs-comment">/**
         * Optimized internal two-arity curry function.
         *
         * @private
         * @category Function
         * @param {Function} fn The function to curry.
         * @return {boolean} `true` if `val` is an array, `false` otherwise.
         * @example
         *
         * var addTwo = function(a, b) {
         *   return a + b;
         * };
         * var curriedAddTwo = curry2(addTwo);
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry2</span><span class="hljs-params">(fn)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{
                <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">arguments</span>.length) {
                    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">throw</span> NO_ARGS_EXCEPTION;
                    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{
                        <span class="hljs-keyword">return</span> fn(a, b);
                    };
                }
                <span class="hljs-keyword">return</span> fn(a, b);
            };
        }

        <span class="hljs-comment">/**
         * Optimized internal three-arity curry function.
         *
         * @private
         * @category Function
         * @param {Function} fn The function to curry.
         * @return {boolean} `true` if `val` is an array, `false` otherwise.
         * @example
         *
         * var addThree = function(a, b, c) {
         *   return a + b + c;
         * };
         * var curriedAddThree = curry2(addThree);
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry3</span><span class="hljs-params">(fn)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b, c)</span> </span>{
                <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">arguments</span>.length) {
                    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">throw</span> NO_ARGS_EXCEPTION;
                    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> curry2(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b, c)</span> </span>{
                        <span class="hljs-keyword">return</span> fn(a, b, c);
                    });
                    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(c)</span> </span>{
                        <span class="hljs-keyword">return</span> fn(a, b, c);
                    };
                }
                <span class="hljs-keyword">return</span> fn(a, b, c);
            };
        }

        <span class="hljs-comment">/**
         * Private function that determines whether or not a provided object has a given method.
         * Does not ignore methods stored on the object's prototype chain. Used for dynamically
         * dispatching Ramda methods to non-Array objects.
         *
         * @private
         * @category Internal
         * @param {Function} methodName The name of the method to check for.
         * @param {Function} obj The object to test.
         * @return {boolean} `true` has a given method, `false` otherwise.
         * @example
         *
         * var person = { name: 'John' };
         * person.shout = function() { alert(this.name); };
         *
         * hasMethod('shout', person); //=&gt; true
         * hasMethod('foo', person); //=&gt; false
         */</span>
        <span class="hljs-keyword">var</span> hasMethod = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(methodName, obj)</span> </span>{
            <span class="hljs-keyword">return</span> obj &amp;&amp; !isArray(obj) &amp;&amp; <span class="hljs-keyword">typeof</span> obj[methodName] === <span class="hljs-string">'function'</span>;
        };

        <span class="hljs-comment">/**
         * TODO
         *
         * @private
         * @category Internal
         * @param {TODO} n TODO
         * @return {string} TODO
         * @example
         *
         * TODO
         */</span>
        <span class="hljs-keyword">var</span> mkArgStr = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n)</span> </span>{
            <span class="hljs-keyword">var</span> arr = [], idx = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (++idx &lt; n) {
                arr[idx] = <span class="hljs-string">"arg"</span> + idx;
            }
            <span class="hljs-keyword">return</span> arr.join(<span class="hljs-string">", "</span>);
        };

        <span class="hljs-comment">/**
         * Wraps a function of any arity (including nullary) in a function that accepts exactly `n`
         * parameters. Any extraneous parameters will not be passed to the supplied function.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {number} n The desired arity of the new function.
         * @param {Function} fn The function to wrap.
         * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
         * arity `n`.
         * @example
         *
         * var takesTwoArgs = function(a, b) {
         *   return [a, b];
         * };
         * takesTwoArgs.length; //=&gt; 2
         * takesTwoArgs(1, 2); //=&gt; [1, 2]
         *
         * var takesOneArg = ramda.nAry(1, takesTwoArgs);
         * takesOneArg.length; //=&gt; 1
         * // Only `n` arguments are passed to the wrapped function
         * takesOneArg(1, 2); //=&gt; [1, undefined]
         */</span>
        <span class="hljs-keyword">var</span> nAry = R.nAry = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">var</span> cache = {
                <span class="hljs-number">0</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(func)</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                        <span class="hljs-keyword">return</span> func.call(<span class="hljs-keyword">this</span>);
                    };
                },
                <span class="hljs-number">1</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(func)</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arg0)</span> </span>{
                        <span class="hljs-keyword">return</span> func.call(<span class="hljs-keyword">this</span>, arg0);
                    };
                },
                <span class="hljs-number">2</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(func)</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arg0, arg1)</span> </span>{
                        <span class="hljs-keyword">return</span> func.call(<span class="hljs-keyword">this</span>, arg0, arg1);
                    };
                },
                <span class="hljs-number">3</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(func)</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arg0, arg1, arg2)</span> </span>{
                        <span class="hljs-keyword">return</span> func.call(<span class="hljs-keyword">this</span>, arg0, arg1, arg2);
                    };
                }
            };</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <pre><code>For example:
cache[<span class="hljs-number">5</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(func)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg0, arg1, arg2, arg3, arg4)</span> </span>{
        <span class="hljs-keyword">return</span> func.call(<span class="hljs-keyword">this</span>, arg0, arg1, arg2, arg3, arg4);
    }
};
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>
            <span class="hljs-keyword">var</span> makeN = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n)</span> </span>{
                <span class="hljs-keyword">var</span> fnArgs = mkArgStr(n);
                <span class="hljs-keyword">var</span> body = [
                        <span class="hljs-string">"    return function("</span> + fnArgs + <span class="hljs-string">") {"</span>,
                        <span class="hljs-string">"        return func.call(this"</span> + (fnArgs ? <span class="hljs-string">", "</span> + fnArgs : <span class="hljs-string">""</span>) + <span class="hljs-string">");"</span>,
                    <span class="hljs-string">"    }"</span>
                ].join(<span class="hljs-string">"\n"</span>);
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">"func"</span>, body);
            };

            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n, fn)</span> </span>{
                <span class="hljs-keyword">return</span> (cache[n] || (cache[n] = makeN(n)))(fn);
            };
        }());

        <span class="hljs-comment">/**
         * Wraps a function of any arity (including nullary) in a function that accepts exactly 1
         * parameter. Any extraneous parameters will not be passed to the supplied function.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} fn The function to wrap.
         * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
         * arity 1.
         * @example
         *
         * var takesTwoArgs = function(a, b) {
         *   return [a, b];
         * };
         * takesTwoArgs.length; //=&gt; 2
         * takesTwoArgs(1, 2); //=&gt; [1, 2]
         *
         * var takesOneArg = ramda.unary(1, takesTwoArgs);
         * takesOneArg.length; //=&gt; 1
         * // Only 1 argument is passed to the wrapped function
         * takesOneArg(1, 2); //=&gt; [1, undefined]
         */</span>
        R.unary = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn)</span> </span>{
            <span class="hljs-keyword">return</span> nAry(<span class="hljs-number">1</span>, fn);
        };

        <span class="hljs-comment">/**
         * Wraps a function of any arity (including nullary) in a function that accepts exactly 2
         * parameters. Any extraneous parameters will not be passed to the supplied function.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} fn The function to wrap.
         * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
         * arity 2.
         * @example
         *
         * var takesThreeArgs = function(a, b, c) {
         *   return [a, b, c];
         * };
         * takesThreeArgs.length; //=&gt; 3
         * takesThreeArgs(1, 2, 3); //=&gt; [1, 2, 3]
         *
         * var takesTwoArgs = ramda.binary(1, takesThreeArgs);
         * takesTwoArgs.length; //=&gt; 2
         * // Only 2 arguments are passed to the wrapped function
         * takesTwoArgs(1, 2, 3); //=&gt; [1, 2, undefined]
         */</span>
        <span class="hljs-keyword">var</span> binary = R.binary = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn)</span> </span>{
            <span class="hljs-keyword">return</span> nAry(<span class="hljs-number">2</span>, fn);
        };

        <span class="hljs-comment">/**
         * Wraps a function of any arity (including nullary) in a function that accepts exactly `n`
         * parameters. Unlike `nAry`, which passes only `n` arguments to the wrapped function,
         * functions produced by `arity` will pass all provided arguments to the wrapped function.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {number} n The desired arity of the returned function.
         * @param {Function} fn The function to wrap.
         * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
         * arity `n`.
         * @example
         *
         * var takesTwoArgs = function(a, b) {
         *   return [a, b];
         * };
         * takesTwoArgs.length; //=&gt; 2
         * takesTwoArgs(1, 2); //=&gt; [1, 2]
         *
         * var takesOneArg = ramda.unary(1, takesTwoArgs);
         * takesOneArg.length; //=&gt; 1
         * // All arguments are passed through to the wrapped function
         * takesOneArg(1, 2); //=&gt; [1, 2]
         */</span>
        <span class="hljs-keyword">var</span> arity = R.arity = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">var</span> cache = {
                <span class="hljs-number">0</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(func)</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                        <span class="hljs-keyword">return</span> func.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
                    };
                },
                <span class="hljs-number">1</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(func)</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arg0)</span> </span>{
                        <span class="hljs-keyword">return</span> func.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
                    };
                },
                <span class="hljs-number">2</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(func)</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arg0, arg1)</span> </span>{
                        <span class="hljs-keyword">return</span> func.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
                    };
                },
                <span class="hljs-number">3</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(func)</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arg0, arg1, arg2)</span> </span>{
                        <span class="hljs-keyword">return</span> func.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
                    };
                }
            };</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <pre><code>For example:
cache[<span class="hljs-number">5</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(func)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg0, arg1, arg2, arg3, arg4)</span> </span>{
        <span class="hljs-keyword">return</span> func.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }
};
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>
            <span class="hljs-keyword">var</span> makeN = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n)</span> </span>{
                <span class="hljs-keyword">var</span> fnArgs = mkArgStr(n);
                <span class="hljs-keyword">var</span> body = [
                        <span class="hljs-string">"    return function("</span> + fnArgs + <span class="hljs-string">") {"</span>,
                    <span class="hljs-string">"        return func.apply(this, arguments);"</span>,
                    <span class="hljs-string">"    }"</span>
                ].join(<span class="hljs-string">"\n"</span>);
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">"func"</span>, body);
            };

            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n, fn)</span> </span>{
                <span class="hljs-keyword">return</span> (cache[n] || (cache[n] = makeN(n)))(fn);
            };
        }());

        <span class="hljs-comment">/**
         * Turns a named method of an object (or object prototype) into a function that can be
         * called directly. Passing the optional `len` parameter restricts the returned function to
         * the initial `len` parameters of the method.
         *
         * The returned function is curried and accepts `len + 1` parameters (or `method.length + 1`
         * when `len` is not specified), and the final parameter is the target object.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {string} name The name of the method to wrap.
         * @param {Object} obj The object to search for the `name` method.
         * @param [len] The desired arity of the wrapped method.
         * @return {Function} A new function or `undefined` if the specified method is not found.
         * @example
         *
         *
         * var charAt = ramda.invoker('charAt', String.prototype);
         * charAt(6, 'abcdefghijklm'); //=&gt; 'g'
         *
         * var join = ramda.invoker('join', Array.prototype);
         * var firstChar = charAt(0);
         * join('', ramda.map(firstChar, ["light", "ampliifed", "stimulated", "emission", "radiation"]));
         * //=&gt; 'laser'
         */</span>
        <span class="hljs-keyword">var</span> invoker = R.invoker = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, obj, len)</span> </span>{
            <span class="hljs-keyword">var</span> method = obj[name];
            <span class="hljs-keyword">var</span> length = len === undef ? method.length : len;
            <span class="hljs-keyword">return</span> method &amp;&amp; curry(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length) {
                    <span class="hljs-keyword">var</span> target = <span class="hljs-built_in">Array</span>.prototype.pop.call(<span class="hljs-built_in">arguments</span>);
                    <span class="hljs-keyword">var</span> targetMethod = target[name];
                    <span class="hljs-keyword">if</span> (targetMethod == method) {
                        <span class="hljs-keyword">return</span> targetMethod.apply(target, <span class="hljs-built_in">arguments</span>);
                    }
                }
                <span class="hljs-keyword">return</span> undef;
            }, length + <span class="hljs-number">1</span>);
        };

        <span class="hljs-comment">/**
         * Accepts a function `fn` and any number of transformer functions and returns a new
         * function. When the new function is invoked, it calls the function `fn` with parameters
         * consisting of the result of calling each supplied handler on successive arguments to the
         * new function. For example:
         *
         * ```javascript
         *   var useWithExample = invoke(someFn, transformerFn1, transformerFn2);
         *
         *   // This invocation:
         *   useWithExample('x', 'y');
         *   // Is functionally equivalent to:
         *   someFn(transformerFn1('x'), transformerFn2('y'))
         * ```
         *
         * If more arguments are passed to the returned function than transformer functions, those
         * arguments are passed directly to `fn` as additional parameters. If you expect additional
         * arguments that don't need to be transformed, although you can ignore them, it's best to
         * pass an identity function so that the new function reports the correct arity.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} fn The function to wrap.
         * @param {...Function} transformers A variable number of transformer functions
         * @return {Function} The wrapped function.
         * @example
         *
         * var double = function(y) { return y * 2; };
         * var square = function(x) { return x * x; };
         * var add = function(a, b) { return a + b; };
         * // Adds any number of arguments together
         * var addAll = function() {
         *   return ramda.reduce(add, 0, arguments);
         * };
         *
         * // Basic example
         * var addDoubleAndSquare = ramda.useWith(addAll, double, square);
         *
         * addDoubleAndSquare(10, 5); //≅ addAll(double(10), square(5));
         * //=&gt; 125
         *
         * // Example of passing more arguments than transformers
         * addDoubleAndSquare(10, 5, 100); //≅ addAll(double(10), square(5), 100);
         * //=&gt; 225
         *
         * // But if you're expecting additional arguments that don't need transformation, it's best
         * // to pass transformer functions so the resulting function has the correct arity
         * var addDoubleAndSquareWithExtraParams = ramda.useWith(addAll, double, square, ramda.identity);
         * addDoubleAndSquare(10, 5, 100); //≅ addAll(double(10), square(5), ramda.identity(100));
         * //=&gt; 225
         */</span>
        <span class="hljs-keyword">var</span> useWith = R.useWith = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn <span class="hljs-comment">/*, transformers */</span>)</span> </span>{
            <span class="hljs-keyword">var</span> transformers = _slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);
            <span class="hljs-keyword">var</span> tlen = transformers.length;
            <span class="hljs-keyword">return</span> curry(arity(tlen, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">var</span> args = [], idx = -<span class="hljs-number">1</span>;
                <span class="hljs-keyword">while</span> (++idx &lt; tlen) {
                    args.push(transformers[idx](<span class="hljs-built_in">arguments</span>[idx]));
                }
                <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, args.concat(_slice(<span class="hljs-built_in">arguments</span>, tlen)));
            }));
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>A two-step version of the <code>useWith</code> function.  This would allow us to write <code>project</code>, currently written
as <code>useWith(map, pickAll, identity)</code>, as, instead, <code>use(map).over(pickAll, identity)</code>, which is a bit
more explicit.
TODO: One of these versions should be eliminated eventually.  So not worrying about the duplication for now.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.use = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn)</span> </span>{
            <span class="hljs-keyword">return</span> {
                over: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-comment">/*transformers*/</span>)</span> </span>{
                    <span class="hljs-keyword">var</span> transformers = _slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>);
                    <span class="hljs-keyword">var</span> tlen = transformers.length;
                    <span class="hljs-keyword">return</span> curry(arity(tlen, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                        <span class="hljs-keyword">var</span> args = [], idx = -<span class="hljs-number">1</span>;
                        <span class="hljs-keyword">while</span> (++idx &lt; tlen) {
                            args.push(transformers[idx](<span class="hljs-built_in">arguments</span>[idx]));
                        }
                        <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, args.concat(_slice(<span class="hljs-built_in">arguments</span>, tlen)));
                    }));
                }
            };
        };

        <span class="hljs-comment">/**
         * Iterate over an input `list`, calling a provided function `fn` for each element in the
         * list.
         *
         * `fn` receives one argument: *(value)*.
         *
         * Note: `ramda.each` does not skip deleted or unassigned indices (sparse arrays), unlike
         * the native `Array.prototype.forEach` method. For more details on this behavior, see:
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
         *
         * Also note that, unlike `Array.prototype.forEach`, Ramda's `each` returns the original
         * array.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function to invoke. Receives one argument, `value`.
         * @param {Array} list The list to iterate over.
         * @return {Array} The original list.
         * @example
         *
         * ramda.each(function(num) {
         *   console.log(num + 100);
         * }, [1, 2, 3]); //=&gt; [1, 2, 3]
         * //-&gt; 101
         * //-&gt; 102
         * //-&gt; 103
         */</span>
        <span class="hljs-keyword">var</span> each = R.each = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_each</span><span class="hljs-params">(list)</span> </span>{
                <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length;
                <span class="hljs-keyword">while</span> (++idx &lt; len) {
                    fn(list[idx]);
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>i can’t bear not to return <em>something</em></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">return</span> list;
            }
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? _each : _each(list);
        };

        <span class="hljs-comment">/**
         * Like `each`, but but passes additional parameters to the predicate function.
         *
         * `fn` receives three arguments: *(value, index, list)*.
         *
         * Note: `ramda.each.idx` does not skip deleted or unassigned indices (sparse arrays),
         * unlike the native `Array.prototype.forEach` method. For more details on this behavior,
         * see:
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
         *
         * Also note that, unlike `Array.prototype.forEach`, Ramda's `each` returns the original
         * array.
         *
         * @static
         * @memberOf R
         * @category List
         * @alias forEach
         * @param {Function} fn The function to invoke. Receives three arguments: (`value`, `index`,
         * `list`).
         * @param {Array} list The list to iterate over.
         * @return {Array} The original list.
         * @example
         *
         * // Note that having access to the original `list` allows for mutation. While you *can* do
         * // this, it's very un-functional behavior:
         * ramda.each.idx(function(num, idx, list) {
         *   list[idx] = num + 100;
         * }, [1, 2, 3]); //=&gt; [101, 102, 103]
         */</span>
        each.idx = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_eachIdx</span><span class="hljs-params">(list)</span> </span>{
                <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length;
                <span class="hljs-keyword">while</span> (++idx &lt; len) {
                    fn(list[idx], idx, list);
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>i can’t bear not to return <em>something</em></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">return</span> list;
            }
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? _eachIdx : _eachIdx(list);
        };

        aliasFor(<span class="hljs-string">"each"</span>).is(<span class="hljs-string">"forEach"</span>);

        <span class="hljs-comment">/**
         * Creates a shallow copy of an array.
         *
         * @static
         * @memberOf R
         * @category Array
         * @param {Array} list The list to clone.
         * @return {Array} A new copy of the original list.
         * @example
         *
         * var numbers = [1, 2, 3];
         * var numbersClone = ramda.clone(numbers); //=&gt; [1, 2, 3]
         * numbers === numbersClone; //=&gt; false
         *
         * // Note that this is a shallow clone--it does not clone complex values:
         * var objects = [{}, {}, {}];
         * var objectsClone = ramda.clone(objects);
         * objects[0] === objectsClone[0]; //=&gt; true
         */</span>
        <span class="hljs-keyword">var</span> clone = R.clone = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(list)</span> </span>{
            <span class="hljs-keyword">return</span> _slice(list);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <h2 id="core-functions">Core Functions</h2>

            </div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * Reports whether an array is empty.
         *
         * @static
         * @memberOf R
         * @category Array
         * @param {Array} arr The array to consider.
         * @return {boolean} `true` if the `arr` argument has a length of 0 or if `arr` is a falsy
         * value (e.g. undefined).
         * @example
         *
         * ramda.isEmpty([1, 2, 3]); //=&gt; false
         * ramda.isEmpty([]); //=&gt; true
         * ramda.isEmpty(); //=&gt; true
         * ramda.isEmpty(null); //=&gt; true
         */</span>
        <span class="hljs-keyword">var</span> isEmpty = R.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arr)</span> </span>{
            <span class="hljs-keyword">return</span> !arr || !arr.length;
        };

        <span class="hljs-comment">/**
         * Returns a new list with the given element at the front, followed by the contents of the
         * list.
         *
         * @static
         * @memberOf R
         * @category Array
         * @alias cons
         * @param {*} el The item to add to the head of the output list.
         * @param {Array} arr The array to add to the tail of the output list.
         * @return {Array} A new array.
         * @example
         *
         * ramda.prepend('fee', ['fi', 'fo', 'fum']); //=&gt; ['fee', 'fi', 'fo', 'fum']
         */</span>
        <span class="hljs-keyword">var</span> prepend = R.prepend = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(el, arr)</span> </span>{
            <span class="hljs-keyword">return</span> concat([el], arr);
        };

        aliasFor(<span class="hljs-string">"prepend"</span>).is(<span class="hljs-string">"cons"</span>);

        <span class="hljs-comment">/**
         * Returns the first element in a list.
         *
         * @static
         * @memberOf R
         * @category Array
         * @alias car, first
         * @param {Array} [arr=[]] The array to consider.
         * @return {*} The first element of the list, or `undefined` if the list is empty.
         * @example
         *
         * ramda.head(['fi', 'fo', 'fum']); //=&gt; 'fi'
         */</span>
        <span class="hljs-keyword">var</span> head = R.head = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arr)</span> </span>{
            arr = arr || [];
            <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];
        };

        aliasFor(<span class="hljs-string">"head"</span>).is(<span class="hljs-string">"car"</span>).and(<span class="hljs-string">"first"</span>);

        <span class="hljs-comment">/**
         * Returns the last element from a list.
         *
         * @static
         * @memberOf R
         * @category Array
         * @param {Array} [arr=[]] The array to consider.
         * @return {*} The last element of the list, or `undefined` if the list is empty.
         * @example
         *
         * ramda.last(['fi', 'fo', 'fum']); //=&gt; 'fum'
         */</span>
        R.last = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arr)</span> </span>{
            arr = arr || [];
            <span class="hljs-keyword">return</span> arr[arr.length - <span class="hljs-number">1</span>];
        };

        <span class="hljs-comment">/**
         * Returns all but the first element of a list. If the list provided has the `tail` method,
         * it will instead return `list.tail()`.
         *
         * @static
         * @memberOf R
         * @category Array
         * @alias cdr
         * @param {Array} [arr=[]] The array to consider.
         * @return {Array} A new array containing all but the first element of the input list, or an
         * empty list if the input list is a falsy value (e.g. `undefined`).
         * @example
         *
         * ramda.tail(['fi', 'fo', 'fum']); //=&gt; ['fo', 'fum']
         */</span>
        <span class="hljs-keyword">var</span> tail = R.tail = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arr)</span> </span>{
            arr = arr || [];
            <span class="hljs-keyword">if</span> (hasMethod(<span class="hljs-string">'tail'</span>, arr)) {
                <span class="hljs-keyword">return</span> arr.tail();
            }
            <span class="hljs-keyword">return</span> (arr.length &gt; <span class="hljs-number">1</span>) ? _slice(arr, <span class="hljs-number">1</span>) : [];
        };

        aliasFor(<span class="hljs-string">"tail"</span>).is(<span class="hljs-string">"cdr"</span>);

        <span class="hljs-comment">/**
         * Returns `true` if the argument is an atom; `false` otherwise. An atom is defined as any
         * value that is not an array, `undefined`, or `null`.
         *
         * @static
         * @memberOf R
         * @category Array
         * @param {*} x The element to consider.
         * @return {boolean} `true` if `x` is an atom, and `false` otherwise.
         * @example
         *
         * ramda.isAtom([]); //=&gt; false
         * ramda.isAtom(null); //=&gt; false
         * ramda.isAtom(undefined); //=&gt; false
         *
         * ramda.isAtom(0); //=&gt; true
         * ramda.isAtom(''); //=&gt; true
         * ramda.isAtom('test'); //=&gt; true
         * ramda.isAtom({}); //=&gt; true
         */</span>
        R.isAtom = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x)</span> </span>{
            <span class="hljs-keyword">return</span> x != <span class="hljs-literal">null</span> &amp;&amp; !isArray(x);
        };

        <span class="hljs-comment">/**
         * Returns a new list containing the contents of the given list, followed by the given
         * element.
         *
         * @static
         * @memberOf R
         * @category Array
         * @alias push
         * @param {*} el The element to add to the end of the new list.
         * @param {Array} list The list whose contents will be added to the beginning of the output
         * list.
         * @return {Array} A new list containing the contents of the old list followed by `el`.
         * @example
         *
         * ramda.append('tests', ['write', 'more']); //=&gt; ['write', 'more', 'tests']
         * ramda.append('tests', []); //=&gt; ['tests']
         * ramda.append(['tests'], ['write', 'more']); //=&gt; ['write', 'more', ['tests']]
         */</span>
        <span class="hljs-keyword">var</span> append = R.append = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(el, list)</span> </span>{
            <span class="hljs-keyword">return</span> concat(list, [el]);
        };

        aliasFor(<span class="hljs-string">"append"</span>).is(<span class="hljs-string">"push"</span>);

        <span class="hljs-comment">/**
         * Returns a new list consisting of the elements of the first list followed by the elements
         * of the second.
         *
         * @static
         * @memberOf R
         * @category Array
         * @param {Array} list1 The first list to merge.
         * @param {Array} list2 The second set to merge.
         * @return {Array} A new array consisting of the contents of `list1` followed by the
         * contents of `list2`. If, instead of an {Array} for `list1`, you pass an object with a `concat`
         * method on it, `concat` will call `list1.concat` and it the value of `list2`.
         * @example
         *
         * ramda.concat([], []); //=&gt; []
         * ramda.concat([4, 5, 6], [1, 2, 3]); //=&gt; [4, 5, 6, 1, 2, 3]
         * ramda.concat("ABC", "DEF"); // "ABCDEF"
         */</span>
        R.concat = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(set1, set2)</span> </span>{
            <span class="hljs-keyword">return</span> (hasMethod(<span class="hljs-string">'concat'</span>, set1)) ? set1.concat(set2) : concat(set1, set2);
        });

        <span class="hljs-comment">/**
         * A function that does nothing but return the parameter supplied to it. Good as a default
         * or placeholder function.
         *
         * @static
         * @memberOf R
         * @category Core
         * @alias I
         * @param {*} x The value to return.
         * @return {*} The input value, `x`.
         * @example
         *
         * ramda.identity(1); //=&gt; 1
         *
         * var obj = {};
         * ramda.identity(obj) === obj; //=&gt; true
         */</span>
        <span class="hljs-keyword">var</span> identity = R.identity = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x)</span> </span>{
            <span class="hljs-keyword">return</span> x;
        };

        aliasFor(<span class="hljs-string">"identity"</span>).is(<span class="hljs-string">"I"</span>);

        <span class="hljs-comment">/**
         * Calls an input function `n` times, returning an array containing the results of those
         * function calls.
         *
         * `fn` is passed one argument: The current value of `n`, which begins at `0` and is
         * gradually incremented to `n - 1`.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
         * @param {number} n A value between `0` and `n - 1`. Increments after each function call.
         * @return {Array} An array containing the return values of all calls to `fn`.
         * @example
         *
         * ramda.times(function(n) { return n; }, 5); //=&gt; [0, 1, 2, 3, 4]
         */</span>
        R.times = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn, n)</span> </span>{
            <span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n);
            <span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (++i &lt; n) {
                arr[i] = fn(i);
            }
            <span class="hljs-keyword">return</span> arr;
        });


        <span class="hljs-comment">/**
         * Returns a fixed list of size `n` containing a specified identical value.
         *
         * @static
         * @memberOf R
         * @category Array
         * @param {*} value The value to repeat.
         * @param {number} n The desired size of the output list.
         * @return {Array} A new array containing `n` `value`s.
         * @example
         *
         * ramda.repeatN('hi', 5); //=&gt; ['hi', 'hi', 'hi', 'hi', 'hi']
         *
         * var obj = {};
         * var repeatedObjs = ramda.repeatN(obj, 5); //=&gt; [{}, {}, {}, {}, {}]
         * repeatedObjs[0] === repeatedObjs[1]; //=&gt; true
         */</span>
        R.repeatN = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value, n)</span> </span>{
            <span class="hljs-keyword">return</span> R.times(R.always(value), n);
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <h2 id="function-functions-">Function functions :-)</h2>

            </div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>These functions make new functions out of old ones.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * Returns a new function which partially applies a value to a given function, where the
         * function is a variadic function that cannot be curried.
         *
         * @private
         * @category Function
         * @param {Function} f The function to partially apply `a` onto.
         * @param {*} a The argument to partially apply onto `f`.
         * @return {Function} A new function.
         * @example
         *
         * var addThree = function(a, b, c) {
         *   return a + b + c;
         * };
         * var partialAdd = partially(add, 1);
         * partialAdd(2, 3); //=&gt; 6
         *
         * // partialAdd is invoked immediately, even though it expects three arguments. This is
         * // because, unlike many functions here, the result of `partially` is not a curried
         * // function.
         * partialAdd(2); //≅ addThree(1, 2, undefined) =&gt; NaN
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partially</span><span class="hljs-params">(f, a)</span></span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> f.apply(<span class="hljs-keyword">this</span>, concat([a], <span class="hljs-built_in">arguments</span>));
            };
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * Basic, right-associative composition function. Accepts two functions and returns the
         * composite function; this composite function represents the operation `var h = f(g(x))`,
         * where `f` is the first argument, `g` is the second argument, and `x` is whatever
         * argument(s) are passed to `h`.
         *
         * This function's main use is to build the more general `compose` function, which accepts
         * any number of functions.
         *
         * @private
         * @category Function
         * @param {Function} f A function.
         * @param {Function} g A function.
         * @return {Function} A new function that is the equivalent of `f(g(x))`.
         * @example
         *
         * var double = function(x) { return x * 2; };
         * var square = function(x) { return x * x; };
         * var squareThenDouble = internalCompose(double, square);
         *
         * squareThenDouble(5); //≅ double(square(5)) =&gt; 50
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">internalCompose</span><span class="hljs-params">(f, g)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> f.call(<span class="hljs-keyword">this</span>, g.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>));
            };
        }

        <span class="hljs-comment">/**
         * Creates a new function that runs each of the functions supplied as parameters in turn,
         * passing the return value of each function invocation to the next function invocation,
         * beginning with whatever arguments were passed to the initial invocation.
         *
         * Note that `compose` is a right-associative function, which means the functions provided
         * will be invoked in order from right to left. In the example `var h = compose(f, g)`,
         * the function `h` is equivalent to `f( g(x) )`, where `x` represents the arguments
         * originally passed to `h`.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {...Function} functions A variable number of functions.
         * @return {Function} A new function which represents the result of calling each of the
         * input `functions`, passing the result of each function call to the next, from right to
         * left.
         * @example
         *
         * var triple = function(x) { return x * 2; };
         * var double = function(x) { return x * 2; };
         * var square = function(x) { return x * x; };
         * var squareThenDoubleThenTriple = ramda.compose(triple, double, square);
         *
         * squareThenDoubleThenTriple(5); //≅ triple(double(square(5))) =&gt; 150
         */</span>
        <span class="hljs-keyword">var</span> compose = R.compose = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{  <span class="hljs-comment">// TODO: type check of arguments?</span>
            <span class="hljs-keyword">var</span> length = <span class="hljs-built_in">arguments</span>.length, func = <span class="hljs-built_in">arguments</span>[--length];
            <span class="hljs-keyword">if</span> (!length) {
                <span class="hljs-keyword">return</span> partially(compose, func);
            }
            <span class="hljs-keyword">while</span> (length--) {
                func = internalCompose(<span class="hljs-built_in">arguments</span>[length], func);
            }
            <span class="hljs-keyword">return</span> func;
        };

        <span class="hljs-comment">/**
         * Creates a new function that runs each of the functions supplied as parameters in turn,
         * passing the return value of each function invocation to the next function invocation,
         * beginning with whatever arguments were passed to the initial invocation.
         *
         * `pipe` is the mirror version of `compose`. `pipe` is left-associative, which means that
         * each of the functions provided is executed in order from left to right.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {...Function} functions A variable number of functions.
         * @return {Function} A new function which represents the result of calling each of the
         * input `functions`, passing the result of each function call to the next, from right to
         * left.
         * @example
         *
         * var triple = function(x) { return x * 2; };
         * var double = function(x) { return x * 2; };
         * var square = function(x) { return x * x; };
         * var squareThenDoubleThenTriple = ramda.pipe(square, double, triple);
         *
         * squareThenDoubleThenTriple(5); //≅ triple(double(square(5))) =&gt; 150
         */</span>
        R.pipe = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{  <span class="hljs-comment">// TODO: type check of arguments?</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length == <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">return</span> partially (R.pipe, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]);
            }
            <span class="hljs-keyword">return</span> compose.apply(<span class="hljs-keyword">this</span>, _slice(<span class="hljs-built_in">arguments</span>).reverse());
        };
        aliasFor(<span class="hljs-string">"pipe"</span>).is(<span class="hljs-string">"sequence"</span>);

        <span class="hljs-comment">/**
         * Returns a new function much like the supplied one, except that the first two arguments'
         * order is reversed.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} fn The function to invoke with its first two parameters reversed.
         * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
         * @example
         *
         * var mergeThree = function(a, b, c) {
         *   ([]).concat(a, b, c);
         * };
         * var numbers = [1, 2, 3];
         *
         * mergeThree(numbers); //=&gt; [1, 2, 3]
         *
         * ramda.flip([1, 2, 3]); //=&gt; [2, 1, 3]
         */</span>
        <span class="hljs-keyword">var</span> flip = R.flip = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, b)</span> </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ?
                  <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, [b, a].concat(_slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>))); } :
                  fn.apply(<span class="hljs-keyword">this</span>, [b, a].concat(_slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>)));
            };
        };

        <span class="hljs-comment">/**
         * Accepts as its arguments a function and any number of values and returns a function that,
         * when invoked, calls the original function with all of the values prepended to the
         * original function's arguments list.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} fn The function to invoke.
         * @param {...*} [args] Arguments to prepend to `fn` when the returned function is invoked.
         * @return {Function} A new function wrapping `fn`. When invoked, it will call `fn`
         * with `args` prepended to `fn`'s arguments list.
         * @example
         *
         * var multiply = function(a, b) { return a * b; };
         * var double = ramda.lPartial(multiply, 2);
         *
         * double(2); //=&gt; 4
         *
         *
         * var greet = function(salutation, title, firstName, lastName) {
         *   return salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
         * };
         * var sayHello = ramda.lPartial(greet, 'Hello');
         * var sayHelloToMs = ramda.lPartial(sayHello, 'Ms.');
         *
         * sayHelloToMs('Jane', 'Jones'); //=&gt; 'Hello, Ms. Jane Jones!'
         */</span>
        R.lPartial = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn <span class="hljs-comment">/*, args */</span>)</span> </span>{
            <span class="hljs-keyword">var</span> args = _slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);
            <span class="hljs-keyword">return</span> arity(<span class="hljs-built_in">Math</span>.max(fn.length - args.length, <span class="hljs-number">0</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, concat(args, <span class="hljs-built_in">arguments</span>));
            });
        };
        aliasFor(<span class="hljs-string">"lPartial"</span>).is(<span class="hljs-string">"applyLeft"</span>);

        <span class="hljs-comment">/**
         * Accepts as its arguments a function and any number of values and returns a function that,
         * when invoked, calls the original function with all of the values appended to the original
         * function's arguments list.
         *
         * Note that `rPartial` is the opposite of `lPartial`: `rPartial` fills `fn`'s arguments
         * from the right to the left.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} fn The function to invoke.
         * @param {...*} [args] Arguments to append to `fn` when the returned function is invoked.
         * @return {Function} A new function wrapping `fn`. When invoked, it will call `fn` with
         * `args` appended to `fn`'s arguments list.
         * @example
         *
         * var greet = function(salutation, title, firstName, lastName) {
         *   return salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
         * };
         * var greetMsJaneJones = ramda.rPartial(greet, 'Ms.', 'Jane', 'Jones');
         *
         * greetMsJaneJones('Hello'); //=&gt; 'Hello, Ms. Jane Jones!'
         */</span>
        R.rPartial = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn)</span> </span>{
            <span class="hljs-keyword">var</span> args = _slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);
            <span class="hljs-keyword">return</span> arity(<span class="hljs-built_in">Math</span>.max(fn.length - args.length, <span class="hljs-number">0</span>), <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, concat(<span class="hljs-built_in">arguments</span>, args));
            });
        };
        aliasFor(<span class="hljs-string">"rPartial"</span>).is(<span class="hljs-string">"applyRight"</span>);

        <span class="hljs-comment">/**
         * Creates a new function that, when invoked, caches the result of calling `fn` for a given
         * argument set and returns the result. Subsequent calls to the memoized `fn` with the same
         * argument set will not result in an additional call to `fn`; instead, the cached result
         * for that set of arguments will be returned.
         *
         * Note that this version of `memoize` effectively handles only string and number
         * parameters.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} fn The function to be wrapped by `memoize`.
         * @return {Function}  Returns a memoized version of `fn`.
         * @example
         *
         * var numberOfCalls = 0;
         * var tracedAdd = function(a, b) {
         *   numberOfCalls += 1;
         *   return a + b;
         * };
         * var memoTrackedAdd = ramda.memoize(trackedAdd);
         *
         * memoAdd(1, 2); //=&gt; 3 (numberOfCalls =&gt; 1)
         * memoAdd(1, 2); //=&gt; 3 (numberOfCalls =&gt; 1)
         * memoAdd(2, 3); //=&gt; 5 (numberOfCalls =&gt; 2)
         *
         * // Note that argument order matters
         * memoAdd(2, 1); //=&gt; 3 (numberOfCalls =&gt; 3)
         */</span>
        R.memoize = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn)</span> </span>{
            <span class="hljs-keyword">var</span> cache = {};
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">var</span> position = foldl(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cache, arg)</span> </span>{
                        <span class="hljs-keyword">return</span> cache[arg] || (cache[arg] = {});
                    }, cache,
                    _slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">arguments</span>.length - <span class="hljs-number">1</span>));
                <span class="hljs-keyword">var</span> arg = <span class="hljs-built_in">arguments</span>[<span class="hljs-built_in">arguments</span>.length - <span class="hljs-number">1</span>];
                <span class="hljs-keyword">return</span> (position[arg] || (position[arg] = fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)));
            };
        };

        <span class="hljs-comment">/**
         * Accepts a function `fn` and returns a function that guards invocation of `fn` such that
         * `fn` can only ever be called once, no matter how many times the returned function is
         * invoked.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} fn The function to wrap in a call-only-once wrapper.
         * @return {Function} The wrapped function.
         * @example
         *
         * var alertOnce = ramda.once(alert);
         * alertOnce('Hello!'); // Alerts 'Hello!'
         * alertOnce('Nothing'); // Doesn't alert
         * alertOnce('Again'); // Doesn't alert
         */</span>
        R.once = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn)</span> </span>{
            <span class="hljs-keyword">var</span> called = <span class="hljs-literal">false</span>, result;
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">if</span> (called) {
                    <span class="hljs-keyword">return</span> result;
                }
                called = <span class="hljs-literal">true</span>;
                result = fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
                <span class="hljs-keyword">return</span> result;
            };
        };

        <span class="hljs-comment">/**
         * Wrap a function inside another to allow you to make adjustments to the parameters, or do
         * other processing either before the internal function is called or with its results.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} fn The function to wrap.
         * @param {Function} wrapper The wrapper function.
         * @return {Function} The wrapped function.
         * @example
         *
         * TODO
         */</span>
        R.wrap = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, wrapper)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> wrapper.apply(<span class="hljs-keyword">this</span>, concat([fn], <span class="hljs-built_in">arguments</span>));
            };
        };

        <span class="hljs-comment">/**
         * Wraps a constructor function inside a curried function that can be called with the same
         * arguments and returns the same type.
         *
         * @static
         * @memberOf R
         * @category Function
         * @param {Function} Fn The constructor function to wrap.
         * @return {Function} A wrapped, curried constructor function.
         * @example
         *
         * // Constructor function
         * var Widget = function(config) {
         *   // ...
         * };
         * Widget.prototype = {
         *   // ...
         * };
         * map(construct(Widget), allConfigs); //=&gt; a list of Widgets
         */</span>
        R.construct = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Fn)</span> </span>{
            <span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> Fn();
                Fn.apply(obj, <span class="hljs-built_in">arguments</span>);
                <span class="hljs-keyword">return</span> obj;
            };
            <span class="hljs-keyword">return</span> Fn.length &gt; <span class="hljs-number">1</span> ? curry(nAry(Fn.length, f)) : f;
        };

        <span class="hljs-comment">/**
         * Accepts three functions and returns a new function. When invoked, this new function will
         * invoke the first function, `after`, passing as its arguments the results of invoking the
         * second and third functions with whatever arguments are passed to the new function.
         *
         * For example, a function produced by `fork` is equivalent to:
         *
         * ```javascript
         *   var h = ramda.fork(e, f, g);
         *   h(1, 2); //≅ e( f(1, 2), g(1, 2) )
         * ```
         *
         * @static
         * @memberOf R
         * @category
         * @param {Function} after A function. `after` will be invoked with the return values of
         * `fn1` and `fn2` as its arguments.
         * @param {Function} fn1 A function. It will be invoked with the arguments passed to the
         * returned function. Afterward, its resulting value will be passed to `after` as its first
         * argument.
         * @param {Function} fn2 A function. It will be invoked with the arguments passed to the
         * returned function. Afterward, its resulting value will be passed to `after` as its second
         * argument.
         * @return {Function} A new function.
         * @example
         *
         * var add = function(a, b) { return a + b; };
         * var multiply = function(a, b) { return a * b; };
         * var subtract = function(a, b) { return a - b; };
         *
         * ramda.fork(multiply, add, subtract)(1, 2);
         * //≅ multiply( add(1, 2), subtract(1, 2) );
         * //=&gt; -3
         */</span>
        R.fork = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(after)</span> </span>{
            <span class="hljs-keyword">var</span> fns = _slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;
                <span class="hljs-keyword">return</span> after.apply(<span class="hljs-keyword">this</span>, map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn)</span> </span>{
                    <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, args);
                }, fns));
            };
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <h2 id="list-functions">List Functions</h2>

            </div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>These functions operate on logical lists, here plain arrays.  Almost all of these are curried, and the list
parameter comes last, so you can create a new function by supplying the preceding arguments, leaving the
list parameter off.  For instance:</p>
<pre><code><span class="hljs-comment">// skip third parameter</span>
<span class="hljs-keyword">var</span> checkAllPredicates = reduce(andFn, alwaysTrue);
<span class="hljs-comment">// ... given suitable definitions of odd, lt20, gt5</span>
<span class="hljs-keyword">var</span> test = checkAllPredicates([odd, lt20, gt5]);
<span class="hljs-comment">// test(7) =&gt; true, test(9) =&gt; true, test(10) =&gt; false,</span>
<span class="hljs-comment">// test(3) =&gt; false, test(21) =&gt; false,</span>
</code></pre>
            </div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * Returns a single item by iterating through the list, successively calling the iterator
         * function and passing it an accumulator value and the current value from the array, and
         * then passing the result to the next call.
         *
         * The iterator function receives two values: *(acc, value)*
         *
         * Note: `ramda.foldl` does not skip deleted or unassigned indices (sparse arrays), unlike
         * the native `Array.prototype.filter` method. For more details on this behavior, see:
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
         *
         * @static
         * @memberOf R
         * @category List
         * @alias reduce
         * @param {Function} fn The iterator function. Receives two values, the accumulator and the
         * current element from the array.
         * @param {*} acc The accumulator value.
         * @param {Array} list The list to iterate over.
         * @return {*} The final, accumulated value.
         * @example
         *
         * var numbers = [1, 2, 3];
         * var add = function(a, b) {
         *   return a + b;
         * };
         *
         * foldl(numbers, add, 10); //=&gt; 16
         */</span>
        <span class="hljs-keyword">var</span> foldl = R.foldl =  curry3(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, acc, list)</span> </span>{
            <span class="hljs-keyword">if</span> (hasMethod(<span class="hljs-string">'foldl'</span>, list)) {
                <span class="hljs-keyword">return</span> list.foldl(fn, acc);
            }
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length;
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                acc = fn(acc, list[idx]);
            }
            <span class="hljs-keyword">return</span> acc;
        });
        aliasFor(<span class="hljs-string">"foldl"</span>).is(<span class="hljs-string">"reduce"</span>);

        <span class="hljs-comment">/**
         * Like `foldl`, but passes additional parameters to the predicate function.
         *
         * The iterator function receives four values: *(acc, value, index, list)*
         *
         * Note: `ramda.foldl.idx` does not skip deleted or unassigned indices (sparse arrays),
         * unlike the native `Array.prototype.filter` method. For more details on this behavior,
         * see:
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The iterator function. Receives four values: the accumulator, the
         * current element from `list`, that element's index, and the entire `list` itself.
         * @param {*} acc The accumulator value.
         * @param {Array} list The list to iterate over.
         * @return {*} The final, accumulated value.
         * @example
         *
         * var letters = ['a', 'b', 'c'];
         * var objectify = function(accObject, elem, idx, list) {
         *   return accObject[elem] = idx;
         * };
         *
         * foldl.idx(letters, objectify, {}); //=&gt; { 'a': 0, 'b': 1, 'c': 2 }
         */</span>
        R.foldl.idx = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, acc, list)</span> </span>{
            <span class="hljs-keyword">if</span> (hasMethod(<span class="hljs-string">'foldl'</span>, list)) {
                <span class="hljs-keyword">return</span> list.foldl(fn, acc);
            }
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length;
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                acc = fn(acc, list[idx], idx, list);
            }
            <span class="hljs-keyword">return</span> acc;
        });

        <span class="hljs-comment">/**
         * Returns a single item by iterating through the list, successively calling the iterator
         * function and passing it an accumulator value and the current value from the array, and
         * then passing the result to the next call.
         *
         * Similar to `foldl`, except moves through the input list from the right to the left.
         *
         * The iterator function receives two values: *(acc, value)*
         *
         * Note: `ramda.foldr` does not skip deleted or unassigned indices (sparse arrays), unlike
         * the native `Array.prototype.filter` method. For more details on this behavior, see:
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
         *
         * @static
         * @memberOf R
         * @category List
         * @alias reduceRight
         * @param {Function} fn The iterator function. Receives two values, the accumulator and the
         * current element from the array.
         * @param {*} acc The accumulator value.
         * @param {Array} list The list to iterate over.
         * @return {*} The final, accumulated value.
         * @example
         *
         * var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];
         * var flattenPairs = function(acc, pair) {
         *   return acc.concat(pair);
         * };
         *
         * foldr(numbers, flattenPairs, []); //=&gt; [ 'c', 3, 'b', 2, 'a', 1 ]
         */</span>
        <span class="hljs-keyword">var</span> foldr = R.foldr = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, acc, list)</span> </span>{
            <span class="hljs-keyword">if</span> (hasMethod(<span class="hljs-string">'foldr'</span>, list)) {
                <span class="hljs-keyword">return</span> list.foldr(fn, acc);
            }
            <span class="hljs-keyword">var</span> idx = list.length;
            <span class="hljs-keyword">while</span> (idx--) {
                acc = fn(acc, list[idx]);
            }
            <span class="hljs-keyword">return</span> acc;
        });
        aliasFor(<span class="hljs-string">"foldr"</span>).is(<span class="hljs-string">"reduceRight"</span>);

        <span class="hljs-comment">/**
         * Like `foldr`, but passes additional parameters to the predicate function. Moves through
         * the input list from the right to the left.
         *
         * The iterator function receives four values: *(acc, value, index, list)*.
         *
         * Note: `ramda.foldr.idx` does not skip deleted or unassigned indices (sparse arrays),
         * unlike the native `Array.prototype.filter` method. For more details on this behavior,
         * see:
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The iterator function. Receives four values: the accumulator, the
         * current element from `list`, that element's index, and the entire `list` itself.
         * @param {*} acc The accumulator value.
         * @param {Array} list The list to iterate over.
         * @return {*} The final, accumulated value.
         * @example
         *
         * var letters = ['a', 'b', 'c'];
         * var objectify = function(accObject, elem, idx, list) {
         *   return accObject[elem] = idx;
         * };
         *
         * foldr.idx(letters, objectify, {}); //=&gt; { 'c': 2, 'b': 1, 'a': 0 }
         */</span>
        R.foldr.idx = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn, acc, list)</span> </span>{
            <span class="hljs-keyword">if</span> (hasMethod(<span class="hljs-string">'foldr'</span>, list)) {
                <span class="hljs-keyword">return</span> list.foldr(fn, acc);
            }
            <span class="hljs-keyword">var</span> idx = list.length;
            <span class="hljs-keyword">while</span> (idx--) {
                acc = fn(acc, list[idx], idx, list);
            }
            <span class="hljs-keyword">return</span> acc;
        });

        <span class="hljs-comment">/**
         * Builds a list from a seed value. Accepts an iterator function, which returns either false
         * to stop iteration or an array of length 2 containing the value to add to the resulting
         * list and the seed to be used in the next call to the iterator function.
         *
         * The iterator function receives one argument: *(seed)*.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
         * either false to quit iteration or an array of length two to proceed. The element at index
         * 0 of this array will be added to the resulting array, and the element at index 1 will be
         * passed to the next call to `fn`.
         * @param {*} seed The seed value.
         * @return {Array} The final list.
         * @example TODO
         */</span>
        R.unfoldr = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn, seed)</span> </span>{
            <span class="hljs-keyword">var</span> pair = fn(seed);
            <span class="hljs-keyword">var</span> result = [];
            <span class="hljs-keyword">while</span> (pair &amp;&amp; pair.length) {
                result.push(pair[<span class="hljs-number">0</span>]);
                pair = fn(pair[<span class="hljs-number">1</span>]);
            }
            <span class="hljs-keyword">return</span> result;
        });

        <span class="hljs-comment">/**
         * Returns a new list, constructed by applying the supplied function to every element of the
         * supplied list.
         *
         * Note: `ramda.map` does not skip deleted or unassigned indices (sparse arrays), unlike the
         * native `Array.prototype.map` method. For more details on this behavior, see:
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function to be called on every element of the input `list`.
         * @param {Array} list The list to be iterated over.
         * @return {Array} The new list.
         * @example
         *
         * var double = function(x) {
         *   return x * 2;
         * };
         *
         * ramda.map(double, [1, 2, 3]); //=&gt; [2, 4, 6]
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">if</span> (hasMethod(<span class="hljs-string">'map'</span>, list)) {
                <span class="hljs-keyword">return</span> list.map(fn);
            }
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length, result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                result[idx] = fn(list[idx]);
            }
            <span class="hljs-keyword">return</span> result;
        }
        R.map = curry2(map);

        <span class="hljs-comment">/**
         * Like `map`, but but passes additional parameters to the predicate function.
         *
         * `fn` receives three arguments: *(value, index, list)*.
         *
         * Note: `ramda.map.idx` does not skip deleted or unassigned indices (sparse arrays), unlike
         * the native `Array.prototype.map` method. For more details on this behavior, see:
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function to be called on every element of the input `list`.
         * @param {Array} list The list to be iterated over.
         * @return {Array} The new list.
         * @example
         *
         * var squareEnds = function(elt, idx, list) {
         *   if (idx === 0 || idx === list.length - 1) {
         *     return elt * elt;
         *   }
         *   return elt;
         * };
         *
         * ramda.map.idx(squareEnds, [8, 6, 7, 5, 3, 0, 9];
         * //=&gt; [64, 6, 7, 5, 3, 0, 81]
         */</span>
        R.map.idx = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">if</span> (hasMethod(<span class="hljs-string">'map'</span>, list)) {
                <span class="hljs-keyword">return</span> list.map(fn);
            }
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length, result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                result[idx] = fn(list[idx], idx, list);
            }
            <span class="hljs-keyword">return</span> result;
        });

        <span class="hljs-comment">/**
         * Map, but for objects. Creates an object with the same keys as `obj` and values
         * generated by running each property of `obj` through `fn`. `fn` is passed one argument:
         * *(value)*.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Array} fn A function called for each property in `obj`. Its return value will
         * become a new property on the return object.
         * @param {Object} obj The object to iterate over.
         * @return {Object} A new object with the same keys as `obj` and values that are the result
         * of running each property through `fn`.
         * @example
         *
         * var values = { x: 1, y: 2, z: 3 };
         * var double = function(num) {
         *   return num * 2;
         * };
         *
         * ramda.mapObj(double, values); //=&gt; { x: 2, y: 4, z: 6 }
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>TODO: consider mapObj.key in parallel with mapObj.idx.  Also consider folding together with <code>map</code> implementation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.mapObj = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn, obj)</span> </span>{
            <span class="hljs-keyword">return</span> foldl(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(acc, key)</span> </span>{
                acc[key] = fn(obj[key]);
                <span class="hljs-keyword">return</span> acc;
            }, {}, keys(obj));
        });

        <span class="hljs-comment">/**
         * Like `mapObj`, but but passes additional arguments to the predicate function. The
         * predicate function is passed three arguments: *(value, key, obj)*.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Array} fn A function called for each property in `obj`. Its return value will
         * become a new property on the return object.
         * @param {Object} obj The object to iterate over.
         * @return {Object} A new object with the same keys as `obj` and values that are the result
         * of running each property through `fn`.
         * @example
         *
         * var values = { x: 1, y: 2, z: 3 };
         * var double = function(num, key, obj) {
         *   return key + num;
         * };
         *
         * ramda.mapObj(double, values); //=&gt; { x: 'x2', y: 'y4', z: 'z6' }
         */</span>
        R.mapObj.idx = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn, obj)</span> </span>{
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_mapObjIdx</span><span class="hljs-params">(obj)</span> </span>{
                <span class="hljs-keyword">return</span> foldl(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(acc, key)</span> </span>{
                    acc[key] = fn(obj[key], key, obj);
                    <span class="hljs-keyword">return</span> acc;
                }, {}, keys(obj));
            }
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? _mapObjIdx : _mapObjIdx(obj);
        };

        <span class="hljs-comment">/**
         * Returns the number of elements in the array by returning `arr.length`.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Array} arr The array to inspect.
         * @return {number} The size of the array.
         * @example
         *
         * ramda.size([]); //=&gt; 0
         * ramda.size([1, 2, 3]); //=&gt; 3
         */</span>
        R.size = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arr)</span> </span>{
            <span class="hljs-keyword">return</span> arr.length;
        };

        <span class="hljs-comment">/**
         * Returns a new list containing only those items that match a given predicate function.
         * The predicate function is passed one argument: *(value)*.
         *
         * Note that `ramda.filter` does not skip deleted or unassigned indices, unlike the native
         * `Array.prototype.filter` method. For more details on this behavior, see:
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Description
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function called per iteration.
         * @param {Array} list The collection to iterate over.
         * @return {Array} The new filtered array.
         * @example
         *
         * var isEven = function(n) {
         *     return n % 2 === 0;
         * };
         * var evens = ramda.filter(isEven, [1, 2, 3, 4]); // =&gt; [2, 4]
         */</span>
        <span class="hljs-keyword">var</span> filter = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">if</span> (hasMethod(<span class="hljs-string">'filter'</span>, list)) {
                <span class="hljs-keyword">return</span> list.filter(fn);
            }
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length, result = [];
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                <span class="hljs-keyword">if</span> (fn(list[idx])) {
                    result.push(list[idx]);
                }
            }
            <span class="hljs-keyword">return</span> result;
        };

        R.filter = curry2(filter);

        <span class="hljs-comment">/**
         * Like `filter`, but passes additional parameters to the predicate function. The predicate
         * function is passed three arguments: *(value, index, list)*.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function called per iteration.
         * @param {Array} list The collection to iterate over.
         * @return {Array} The new filtered array.
         * @example
         *
         * var lastTwo = function(val, idx, list) {
         *     return list.length - idx &lt;= 2;
         * };
         * ramda.filter.idx(lastTwo, [8, 6, 7, 5, 3, 0, 9]); //=&gt; [0, 9]
         */</span>
        <span class="hljs-keyword">var</span> filterIdx = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">if</span> (hasMethod(<span class="hljs-string">'filter'</span>, list)) {
                <span class="hljs-keyword">return</span> list.filter(fn);
            }
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length, result = [];
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                <span class="hljs-keyword">if</span> (fn(list[idx], idx, list)) {
                    result.push(list[idx]);
                }
            }
            <span class="hljs-keyword">return</span> result;
        };

        R.filter.idx = curry2(filterIdx);

        <span class="hljs-comment">/**
         * Similar to `filter`, except that it keeps only values for which the given predicate
         * function returns falsy. The predicate function is passed one argument: *(value)*.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function called per iteration.
         * @param {Array} list The collection to iterate over.
         * @return {Array} The new filtered array.
         * @example
         *
         * var isEven = function(n) {
         *     return n % 2 === 0;
         * };
         * var odds = ramda.reject(isOdd, [1, 2, 3, 4]); // =&gt; [2, 4]
         */</span>
        <span class="hljs-keyword">var</span> reject = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">return</span> filter(not(fn), list);
        };

        R.reject = curry2(reject);

        <span class="hljs-comment">/**
         * Like `reject`, but passes additional parameters to the predicate function. The predicate
         * function is passed three arguments: *(value, index, list)*.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function called per iteration.
         * @param {Array} list The collection to iterate over.
         * @return {Array} The new filtered array.
         * @example
         *
         * var lastTwo = function(val, idx, list) {
         *     return list.length - idx &lt;= 2;
         * };
         *
         * reject.idx(lastTwo, [8, 6, 7, 5, 3, 0, 9]); //=&gt; [8, 6, 7, 5, 3]
         */</span>
        R.reject.idx = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">return</span> filterIdx(not(fn), list);
        });

        <span class="hljs-comment">/**
         * Returns a new list containing the first `n` elements of a given list, passing each value
         * to the supplied predicate function, and terminating when the predicate function returns
         * `false`. Excludes the element that caused the predicate function to fail. The predicate
         * function is passed one argument: *(value)*.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function called per iteration.
         * @param {Array} list The collection to iterate over.
         * @return {Array} A new array.
         * @example
         *
         * var isNotFour = function(x) {
         *   return !(x === 4);
         * };
         *
         * takeWhile(isNotFour, [1, 2, 3, 4]); //=&gt; [1, 2, 3]
         */</span>
        R.takeWhile = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">if</span> (hasMethod(<span class="hljs-string">'takeWhile'</span>, list)) {
                <span class="hljs-keyword">return</span> list.takeWhile(fn);
            }
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length;
            <span class="hljs-keyword">while</span> (++idx &lt; len &amp;&amp; fn(list[idx])) {}
            <span class="hljs-keyword">return</span> _slice(list, <span class="hljs-number">0</span>, idx);
        });


        <span class="hljs-comment">/**
         * Returns a new list containing the first `n` elements of the given list.  If
         * `n &gt; * list.length`, returns a list of `list.length` elements.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {number} n The number of elements to return.
         * @param {Array} list The array to query.
         * @return {Array} A new array containing the first elements of `list`.
         */</span>
        R.take = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(n, list)</span> </span>{
            <span class="hljs-keyword">if</span> (hasMethod(<span class="hljs-string">'take'</span>, list)) {
                <span class="hljs-keyword">return</span> list.take(n);
            }
            <span class="hljs-keyword">var</span> ls = clone(list);
            ls.length = <span class="hljs-built_in">Math</span>.min(n, list.length);
            <span class="hljs-keyword">return</span> ls;
        });

        <span class="hljs-comment">/**
         * Returns a new list containing the last `n` elements of a given list, passing each value
         * to the supplied predicate function, beginning when the predicate function returns
         * `true`. Excludes the element that caused the predicate function to fail. The predicate
         * function is passed one argument: *(value)*.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {Function} fn The function called per iteration.
         * @param {Array} list The collection to iterate over.
         * @return {Array} A new array.
         * @example
         *
         * var isNotTwo = function(x) {
         *   return !(x === 2);
         * };
         *
         * skipUntil(isNotFour, [1, 2, 3, 4]); //=&gt; [1, 2, 3]
         */</span>
        R.skipUntil = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length;
            <span class="hljs-keyword">while</span> (++idx &lt; len &amp;&amp; !fn(list[idx])) {}
            <span class="hljs-keyword">return</span> _slice(list, idx);
        });

        <span class="hljs-comment">/**
         * Returns a new list containing all but the first `n` elements of the given `list`.
         *
         * @static
         * @memberOf R
         * @category List
         * @param {number} n The number of elements of `list` to skip.
         * @param {Array} list The array to consider.
         * @return {Array} The last `n` elements of `list`.
         */</span>
        R.skip = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(n, list)</span> </span>{
            <span class="hljs-keyword">if</span> (hasMethod(<span class="hljs-string">'skip'</span>, list)) {
                <span class="hljs-keyword">return</span> list.skip(n);
            }
            <span class="hljs-keyword">return</span> _slice(list, n);
        });
        aliasFor(<span class="hljs-string">'skip'</span>).is(<span class="hljs-string">'drop'</span>);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Returns the first element of the list which matches the predicate, or <code>undefined</code> if no element matches.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.find = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_find</span><span class="hljs-params">(list)</span> </span>{
                <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>;
                <span class="hljs-keyword">var</span> len = list.length;
                <span class="hljs-keyword">while</span> (++idx &lt; len) {
                    <span class="hljs-keyword">if</span> (fn(list[idx])) {
                        <span class="hljs-keyword">return</span> list[idx];
                    }
                }
                <span class="hljs-keyword">return</span> undef;
            }
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? _find : _find(list);
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Returns the index of first element of the list which matches the predicate, or <code>undefined</code> if no element matches.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.findIndex = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">var</span> len = list.length;
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                <span class="hljs-keyword">if</span> (fn(list[idx])) {
                    <span class="hljs-keyword">return</span> idx;
                }
            }
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Returns the last element of the list which matches the predicate, or <code>undefined</code> if no element matches.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.findLast = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = list.length;
            <span class="hljs-keyword">while</span> (--idx) {
                <span class="hljs-keyword">if</span> (fn(list[idx])) {
                    <span class="hljs-keyword">return</span> list[idx];
                }
            }
            <span class="hljs-keyword">return</span> undef;
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Returns the index of last element of the list which matches the predicate, or <code>undefined</code> if no element matches.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.findLastIndex = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = list.length;
            <span class="hljs-keyword">while</span> (--idx) {
                <span class="hljs-keyword">if</span> (fn(list[idx])) {
                    <span class="hljs-keyword">return</span> idx;
                }
            }
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Returns <code>true</code> if all elements of the list match the predicate, <code>false</code> if there are any that don’t.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> all = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (++i &lt; list.length) {
                <span class="hljs-keyword">if</span> (!fn(list[i])) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        };
        R.all = curry2(all);
        aliasFor(<span class="hljs-string">"all"</span>).is(<span class="hljs-string">"every"</span>);


        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Returns <code>true</code> if any elements of the list match the predicate, <code>false</code> if none do.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> any = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (++i &lt; list.length) {
                <span class="hljs-keyword">if</span> (fn(list[i])) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        };
        R.any = curry2(any);
        aliasFor(<span class="hljs-string">"any"</span>).is(<span class="hljs-string">"some"</span>);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Internal implementations of indexOf and lastIndexOf</p>

            </div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Return the position of the first occurrence of an item in an array,
or -1 if the item is not included in the array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> indexOf = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(array, item, from)</span> </span>{
            <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, length = array.length;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> from == <span class="hljs-string">'number'</span>) {
                i = from &lt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, length + from) : from;
            }
            <span class="hljs-keyword">for</span> (; i &lt; length; i++) {
                <span class="hljs-keyword">if</span> (array[i] === item) <span class="hljs-keyword">return</span> i;
            }
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span>
        <span class="hljs-keyword">var</span> lastIndexOf = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(array, item, from)</span> </span>{
            <span class="hljs-keyword">var</span> idx = array.length;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> from == <span class="hljs-string">'number'</span>) {
                idx = from &lt; <span class="hljs-number">0</span> ? idx + from + <span class="hljs-number">1</span> : <span class="hljs-built_in">Math</span>.min(idx, from + <span class="hljs-number">1</span>);
            }
            <span class="hljs-keyword">while</span> (--idx &gt;= <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (array[idx] === item) <span class="hljs-keyword">return</span> idx;
            }
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Returns the first zero-indexed position of an object in a flat list</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.indexOf = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_indexOf</span><span class="hljs-params">(target, list)</span> </span>{
            <span class="hljs-keyword">return</span> indexOf(list, target);
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span>
        R.indexOf.from = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">indexOfFrom</span><span class="hljs-params">(target, fromIdx, list)</span> </span>{
            <span class="hljs-keyword">return</span> indexOf(list, target, fromIdx);
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Returns the last zero-indexed position of an object in a flat list</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.lastIndexOf = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_lastIndexOf</span><span class="hljs-params">(target, list)</span> </span>{
            <span class="hljs-keyword">return</span> lastIndexOf(list, target);
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span>
        R.lastIndexOf.from = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lastIndexOfFrom</span><span class="hljs-params">(target, fromIdx, list)</span> </span>{
            <span class="hljs-keyword">return</span> lastIndexOf(list, target, fromIdx);
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Returns <code>true</code> if the list contains the sought element, <code>false</code> if it does not.  Equality is strict here,
meaning reference equality for objects and non-coercing equality for primitives.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">contains</span><span class="hljs-params">(a, list)</span> </span>{
            <span class="hljs-keyword">return</span> indexOf(list, a) &gt; -<span class="hljs-number">1</span>;
        }
        R.contains = curry2(contains);


        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Returns <code>true</code> if the list contains the sought element, <code>false</code> if it does not, based upon the value
returned by applying the supplied predicated to two list elements.  Equality is strict here, meaning
reference equality for objects and non-coercing equality for primitives.  Probably inefficient.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> containsWith = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(pred, x, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length;
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                <span class="hljs-keyword">if</span> (pred(x, list[idx])) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        };
        R.containsWith = curry3(containsWith);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Returns a new list containing only one copy of each element in the original list.  Equality is strict here,
meaning reference equality for objects and non-coercing equality for primitives.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">var</span> uniq = R.uniq = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">uniq</span><span class="hljs-params">(list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length;
            <span class="hljs-keyword">var</span> result = [], item;
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                item = list[idx];
                <span class="hljs-keyword">if</span> (!contains(item, result)) {
                    result.push(item);
                }
            }
            <span class="hljs-keyword">return</span> result;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>returns <code>true</code> if all of the elements in the <code>list</code> are unique.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.isSet = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(list)</span> </span>{
            <span class="hljs-keyword">var</span> len = list.length;
            <span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (++i &lt; len) {
                <span class="hljs-keyword">if</span> (indexOf(list, list[i], i+<span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Returns a new list containing only one copy of each element in the original list, based upon the value
returned by applying the supplied predicate to two list elements.   Equality is strict here,  meaning
reference equality for objects and non-coercing equality for primitives.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> uniqWith = R.uniqWith = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(pred, list)</span> </span>{
            <span class="hljs-keyword">var</span> idx = -<span class="hljs-number">1</span>, len = list.length;
            <span class="hljs-keyword">var</span> result = [], item;
            <span class="hljs-keyword">while</span> (++idx &lt; len) {
                item = list[idx];
                <span class="hljs-keyword">if</span> (!containsWith(pred, item, result)) {
                    result.push(item);
                }
            }
            <span class="hljs-keyword">return</span> result;
        });


        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>Returns a new list by plucking the same named property off all objects in the list supplied.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> pluck = R.pluck = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(p, list)</span> </span>{
            <span class="hljs-keyword">return</span> map(prop(p), list);
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>Returns a list that contains a flattened version of the supplied list.  For example:</p>
<pre><code>flatten([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">5</span>, [<span class="hljs-number">6</span>, [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, [<span class="hljs-number">9</span>, [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>], <span class="hljs-number">12</span>]]]]);
<span class="hljs-comment">// =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> flatten = R.flatten = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(list)</span> </span>{
            <span class="hljs-keyword">var</span> output = [], idx = <span class="hljs-number">0</span>, value;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, length = list.length; i &lt; length; i++) {
              value = list[i];
              <span class="hljs-keyword">if</span> (isArray(value)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>flatten current level of array or arguments object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                value = flatten(value);
                <span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>, len = value.length;
                output.length += len;
                <span class="hljs-keyword">while</span> (j &lt; len) {
                  output[idx++] = value[j++];
                }
              } <span class="hljs-keyword">else</span> {
                output[idx++] = value;
              }
            }
            <span class="hljs-keyword">return</span> output;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>Creates a new list out of the two supplied by applying the function to each equally-positioned pair in the
lists.  For example,</p>
<pre><code>zipWith(f, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])
<span class="hljs-comment">//    =&gt; [f(1, 'a'), f(2, 'b'), f(3, 'c')];</span>
</code></pre><p>Note that the output list will only be as long as the length of the shorter input list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.zipWith = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, a, b)</span> </span>{
            <span class="hljs-keyword">var</span> rv = [], i = -<span class="hljs-number">1</span>, len = <span class="hljs-built_in">Math</span>.min(a.length, b.length);
            <span class="hljs-keyword">while</span> (++i &lt; len) {
                rv[i] = fn(a[i], b[i]);
            }
            <span class="hljs-keyword">return</span> rv;
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Creates a new list out of the two supplied by yielding the pair of each equally-positioned pair in the
lists.  For example,</p>
<pre><code>zip([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])
<span class="hljs-comment">//    =&gt; [[1, 'a'], [2, 'b'], [3, 'c']];</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.zip = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{ <span class="hljs-comment">// = zipWith(prepend);</span>
            <span class="hljs-keyword">var</span> rv = [];
            <span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">var</span> len = <span class="hljs-built_in">Math</span>.min(a.length, b.length);
            <span class="hljs-keyword">while</span> (++i &lt; len) {
                rv[i] = [a[i], b[i]];
            }
            <span class="hljs-keyword">return</span> rv;
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>Creates a new list out of the two supplied by applying the function to each possible pair in the lists.
 For example,</p>
<pre><code>xProdWith(f, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>])
<span class="hljs-comment">//    =&gt; [f(1, 'a'), f(1, 'b'), f(2, 'a'), f(2, 'b')];</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.xprodWith = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn, a, b)</span> </span>{
            <span class="hljs-keyword">if</span> (isEmpty(a) || isEmpty(b)) {
                <span class="hljs-keyword">return</span> [];
            }
            <span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>, ilen = a.length, j, jlen = b.length, result = []; <span class="hljs-comment">// better to push them all or to do `new Array(ilen * jlen)` and calculate indices?</span>
            <span class="hljs-keyword">while</span> (++i &lt; ilen) {
                j = -<span class="hljs-number">1</span>;
                <span class="hljs-keyword">while</span> (++j &lt; jlen) {
                    result.push(fn(a[i], b[j]));
                }
            }
            <span class="hljs-keyword">return</span> result;
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Creates a new list out of the two supplied by yielding the pair of each possible pair in the lists.
For example,</p>
<pre><code>xProd([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>])
<span class="hljs-comment">//    =&gt; [[1, 'a'], [1, 'b')], [2, 'a'], [2, 'b']];</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.xprod = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, b)</span> </span>{ <span class="hljs-comment">// = xprodWith(prepend); (takes about 3 times as long...)</span>
            <span class="hljs-keyword">if</span> (isEmpty(a) || isEmpty(b)) {
                <span class="hljs-keyword">return</span> [];
            }
            <span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>;
            <span class="hljs-keyword">var</span> ilen = a.length;
            <span class="hljs-keyword">var</span> j;
            <span class="hljs-keyword">var</span> jlen = b.length;
            <span class="hljs-keyword">var</span> result = []; <span class="hljs-comment">// better to push them all or to do `new Array(ilen * jlen)` and calculate indices?</span>
            <span class="hljs-keyword">while</span> (++i &lt; ilen) {
                j = -<span class="hljs-number">1</span>;
                <span class="hljs-keyword">while</span> (++j &lt; jlen) {
                    result.push([a[i], b[j]]);
                }
            }
            <span class="hljs-keyword">return</span> result;
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Returns a new list with the same elements as the original list, just in the reverse order.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.reverse = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(list)</span> </span>{
            <span class="hljs-keyword">return</span> clone(list || []).reverse();
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>// Returns a list of numbers from <code>from</code> (inclusive) to <code>to</code> (exclusive).
For example,</p>
<pre><code>range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// =&gt; [1, 2, 3, 4]</span>
range(<span class="hljs-number">50</span>, <span class="hljs-number">53</span>) <span class="hljs-comment">// =&gt; [50, 51, 52]</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.range = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(from, to)</span> </span>{
            <span class="hljs-keyword">if</span> (from &gt;= to) {
                <span class="hljs-keyword">return</span> [];
            }
            <span class="hljs-keyword">var</span> idx = <span class="hljs-number">0</span>, result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">Math</span>.floor(to) - <span class="hljs-built_in">Math</span>.ceil(from));
            <span class="hljs-keyword">for</span> (; from &lt; to; idx++, from++) {
                result[idx] = from;
            }
            <span class="hljs-keyword">return</span> result;
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Returns the elements of the list as a string joined by a separator.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.join = invoker(<span class="hljs-string">"join"</span>, <span class="hljs-built_in">Array</span>.prototype);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>Returns the sublist of a list starting with the first index and
ending before the second one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.slice = invoker(<span class="hljs-string">"slice"</span>, <span class="hljs-built_in">Array</span>.prototype);
        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span>
        R.slice.from = flip(R.slice)(undef);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Removes the sub-list of <code>list</code> starting at index <code>start</code> and containing
<code>count</code> elements.  <em>Note that this is not destructive</em>: it returns a
copy of the list with the changes.
<small>No lists have been harmed in the application of this function.</small></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.remove = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(start, count, list)</span> </span>{
            <span class="hljs-keyword">return</span> concat(_slice(list, <span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.min(start, list.length)), _slice(list, <span class="hljs-built_in">Math</span>.min(list.length, start + count)));
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>Inserts the supplied element into the list, at index <code>index</code>.  <em>Note
that this is not destructive</em>: it returns a copy of the list with the changes.
<small>No lists have been harmed in the application of this function.</small></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.insert = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(index, elt, list)</span> </span>{
            index = index &lt; list.length &amp;&amp; index &gt;= <span class="hljs-number">0</span> ? index : list.length;
            <span class="hljs-keyword">return</span> concat(append(elt, _slice(list, <span class="hljs-number">0</span>, index)), _slice(list, index));
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>Inserts the sub-list into the list, at index <code>index</code>.  <em>Note  that this
is not destructive</em>: it returns a copy of the list with the changes.
<small>No lists have been harmed in the application of this function.</small></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.insert.all = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(index, elts, list)</span> </span>{
            index = index &lt; list.length &amp;&amp; index &gt;= <span class="hljs-number">0</span> ? index : list.length;
            <span class="hljs-keyword">return</span> concat(concat(_slice(list, <span class="hljs-number">0</span>, index), elts), _slice(list, index));
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>Returns the <code>n</code>th element of a list (zero-indexed)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.nth = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n, list)</span> </span>{
             <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_nth</span><span class="hljs-params">(list)</span> </span>{ <span class="hljs-keyword">return</span> list[n]; } : list[n];
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>Makes a comparator function out of a function that reports whether the first element is less than the second.</p>
<pre><code><span class="hljs-keyword">var</span> cmp = comparator(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{
    <span class="hljs-keyword">return</span> a.age &lt; b.age;
};
sort(cmp, people);
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> comparator = R.comparator = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(pred)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, b)</span> </span>{
                <span class="hljs-keyword">return</span> pred(a, b) ? -<span class="hljs-number">1</span> : pred(b, a) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
            };
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>Returns a copy of the list, sorted according to the comparator function, which should accept two values at a
time and return a negative number if the first value is smaller, a positive number if it’s larger, and zero
if they are equal.  Please note that this is a <strong>copy</strong> of the list.  It does not modify the original.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> sort = R.sort = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(comparator, list)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ?
                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_sort</span><span class="hljs-params">(list)</span> </span>{ <span class="hljs-keyword">return</span> clone(list).sort(comparator); } :
                clone(list).sort(comparator);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>Splits a list into sublists stored in an object, based on the result of calling a String-returning function
on each element, and grouping the results according to values returned.</p>
<pre><code><span class="hljs-keyword">var</span> byGrade = partition(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(student)</span> </span>{
    <span class="hljs-keyword">var</span> score = student.score
    <span class="hljs-keyword">return</span> (score &lt; <span class="hljs-number">65</span>) ? <span class="hljs-string">'F'</span> : (score &lt; <span class="hljs-number">70</span>) ? <span class="hljs-string">'D'</span> :
           (score &lt; <span class="hljs-number">80</span>) ? <span class="hljs-string">'C'</span> : (score &lt; <span class="hljs-number">90</span>) ? <span class="hljs-string">'B'</span> : <span class="hljs-string">'A'</span>;
};
<span class="hljs-keyword">var</span> students = [{name: <span class="hljs-string">"Abby"</span>, score: <span class="hljs-number">84</span>} <span class="hljs-comment">/*, ... */</span>,
                {name: <span class="hljs-string">'Jack'</span>, score: <span class="hljs-number">69</span>}];
byGrade(students);
<span class="hljs-comment">//=&gt; {</span>
<span class="hljs-comment">//   "A": [{name: 'Dianne', score: 99} /*, ... */],</span>
<span class="hljs-comment">//   "B": [{name: "Abby", score: 84} /*, ... */]</span>
<span class="hljs-comment">//   /*, ... */</span>
<span class="hljs-comment">//   "F": [{name: 'Eddy', score: 58}]</span>
<span class="hljs-comment">// }</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span>
        R.partition = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-keyword">return</span> foldl(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(acc, elt)</span> </span>{
                <span class="hljs-keyword">var</span> key = fn(elt);
                acc[key] = append(elt, acc[key] || (acc[key] = []));
                <span class="hljs-keyword">return</span> acc;
            }, {}, list);
        });
        aliasFor(<span class="hljs-string">"partition"</span>).is(<span class="hljs-string">"groupBy"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <h2 id="object-functions">Object Functions</h2>

            </div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>These functions operate on plain Javascript object, adding simple functions to test properties on these
objects.  Many of these are of most use in conjunction with the list functions, operating on lists of
objects.</p>

            </div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>Runs the given function with the supplied object, then returns the object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.tap = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x, fn)</span> </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn === <span class="hljs-string">"function"</span>) { fn(x); }
            <span class="hljs-keyword">return</span> x;
        });
        aliasFor(<span class="hljs-string">"tap"</span>).is(<span class="hljs-string">"K"</span>);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>Tests if two items are equal.  Equality is strict here, meaning reference equality for objects and
non-coercing equality for primitives.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.eq = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_eq</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> a === b; } : a === b;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>Returns a function that when supplied an object returns the indicated property of that object, if it exists.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> prop = R.prop = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(p, obj)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_prop</span><span class="hljs-params">(obj)</span> </span>{ <span class="hljs-keyword">return</span> obj[p]; } :  obj[p];
        };
        aliasFor(<span class="hljs-string">"prop"</span>).is(<span class="hljs-string">"get"</span>); <span class="hljs-comment">// TODO: are we sure?  Matches some other libs, but might want to reserve for other use.</span>


        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>Returns a function that when supplied an object returns the result of running the indicated function on
that object, if it has such a function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.func = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn, obj)</span> </span>{
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_func</span><span class="hljs-params">(obj)</span> </span>{
                <span class="hljs-keyword">return</span> obj[fn].apply(obj, _slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>));
            }
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? _func : _func(obj);
        };


        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>Returns a function that when supplied a property name returns that property on the indicated object, if it
exists.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.props = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj, prop)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_props</span><span class="hljs-params">(prop)</span> </span>{ <span class="hljs-keyword">return</span> obj &amp;&amp; obj[prop]; } : obj &amp;&amp; obj[prop];
        };


        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>Returns a function that always returns the given value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> always = R.always = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(val)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">return</span> val;
            };
        };
        aliasFor(<span class="hljs-string">"always"</span>).is(<span class="hljs-string">"constant"</span>);


        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span>
        <span class="hljs-keyword">var</span> anyBlanks = R.any(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(val)</span> </span>{
            <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span> || val === undef;
        });

        <span class="hljs-keyword">var</span> hasOwnProperty = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;
        <span class="hljs-keyword">var</span> nativeKeys = <span class="hljs-built_in">Object</span>.keys;

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>Returns a list containing the names of all the enumerable own
properties of the supplied object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> keys = R.keys = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj)</span> </span>{
            <span class="hljs-keyword">if</span> (nativeKeys) <span class="hljs-keyword">return</span> nativeKeys(<span class="hljs-built_in">Object</span>(obj));
            <span class="hljs-keyword">var</span> prop, ks = [];
            <span class="hljs-keyword">for</span> (prop <span class="hljs-keyword">in</span> obj) {
                <span class="hljs-keyword">if</span> (hasOwnProperty.call(obj, prop)) {
                    ks.push(prop);
                }
            }
            <span class="hljs-keyword">return</span> ks;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>Returns a list containing the names of all the
properties of the supplied object, including prototype properties.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.keysIn = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj)</span> </span>{
            <span class="hljs-keyword">var</span> prop, ks = [];
            <span class="hljs-keyword">for</span> (prop <span class="hljs-keyword">in</span> obj) {
                ks.push(prop);
            }
            <span class="hljs-keyword">return</span> ks;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>Returns a list of all the enumerable own properties of the supplied object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.values = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj)</span> </span>{
            <span class="hljs-keyword">var</span> prop, props = keys(obj),
                length = props.length,
                vals = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(length);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
                vals[i] = obj[props[i]];
            }
            <span class="hljs-keyword">return</span> vals;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>Returns a list of all the properties, including prototype properties,
of the supplied object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.valuesIn = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj)</span> </span>{
            <span class="hljs-keyword">var</span> prop, vs = [];
            <span class="hljs-keyword">for</span> (prop <span class="hljs-keyword">in</span> obj) {
                vs.push(obj[prop]);
            }
            <span class="hljs-keyword">return</span> vs;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>internal helper function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pickWith</span><span class="hljs-params">(test, obj)</span> </span>{
            <span class="hljs-keyword">var</span> copy = {},
                props = keys(obj), prop, val;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = props.length; i &lt; len; i++) {
                prop = props[i];
                val = obj[prop];
                <span class="hljs-keyword">if</span> (test(val, prop, obj)) {
                    copy[prop] = val;
                }
            }
            <span class="hljs-keyword">return</span> copy;
        }

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>Returns a partial copy of an object containing only the keys specified.  If the key does not exist, the
property is ignored</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.pick = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pick</span><span class="hljs-params">(names, obj)</span> </span>{
            <span class="hljs-keyword">return</span> pickWith(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(val, key)</span> </span>{
                <span class="hljs-keyword">return</span> contains(key, names);
            }, obj);
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>Returns a partial copy of an object omitting the keys specified.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.omit = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">omit</span><span class="hljs-params">(names, obj)</span> </span>{
            <span class="hljs-keyword">return</span> pickWith(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(val, key)</span> </span>{
                <span class="hljs-keyword">return</span> !contains(key, names);
            }, obj);
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span>
        R.pickWith = curry2(pickWith);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>Similar to <code>pick</code> except that this one includes a <code>key: undefined</code> pair for properties that don’t exist.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> pickAll = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(names, obj)</span> </span>{
            <span class="hljs-keyword">var</span> copy = {};
            each(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> </span>{
                copy[name] = obj[name];
            }, names);
            <span class="hljs-keyword">return</span> copy;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span>
        R.pickAll = curry2(pickAll);


        <span class="hljs-comment">/**
         * Assigns own enumerable properties of the other object to the destination
         * object prefering items in other.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} other The other object to merge with destination.
         * @returns {Object} Returns the destination object.
         *
         * @example
         * extend({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
         * // =&gt; { 'name': 'fred', 'age': 40 }
         */</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend</span><span class="hljs-params">(destination, other)</span> </span>{
            <span class="hljs-keyword">var</span> props = keys(other),
                i = -<span class="hljs-number">1</span>, length = props.length;
            <span class="hljs-keyword">while</span> (++i &lt; length) {
                destination[props[i]] = other[props[i]];
            }
            <span class="hljs-keyword">return</span> destination;
        }

        <span class="hljs-comment">/**
         * Create a new object with the own properties of a
         * merged with the own properties of object b.
         *
         * @static
         * @memberOf R
         * @category Object
         * @param {Object} a source object
         * @param {Object} b object with higher precendence in output
         * @returns {Object} Returns the destination object.
         *
         * @example
         * mixin({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
         * // =&gt; { 'name': 'fred', 'age': 40 }
         */</span>
        R.mixin = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> extend(extend({}, a), b);
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>Reports whether two functions have the same value for the specified property.  Useful as a curried predicate.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.eqProps = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(prop, obj1, obj2)</span> </span>{
            <span class="hljs-keyword">var</span> f1 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eqPropsCurried1</span><span class="hljs-params">(obj1, obj2)</span> </span>{
                <span class="hljs-keyword">var</span> f2 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eqPropsCurried2</span><span class="hljs-params">(obj2)</span> </span>{
                    <span class="hljs-keyword">return</span> obj1[prop] === obj2[prop];
                };
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? f2 : f2(obj2);
            };
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? f1 :
                <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">3</span> ? f1(obj1) :
                    f1(obj1, obj2);
        };


        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>internal helper for <code>where</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">satisfiesSpec</span><span class="hljs-params">(spec, parsedSpec, testObj)</span> </span>{
            <span class="hljs-keyword">if</span> (spec === testObj) { <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }
            <span class="hljs-keyword">if</span> (testObj == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; }
            parsedSpec.fn = parsedSpec.fn || [];
            parsedSpec.obj = parsedSpec.obj || [];
            <span class="hljs-keyword">var</span> key, val, i = -<span class="hljs-number">1</span>, fnLen = parsedSpec.fn.length, j = -<span class="hljs-number">1</span>, objLen = parsedSpec.obj.length;
            <span class="hljs-keyword">while</span> (++i &lt; fnLen) {
                key = parsedSpec.fn[i];
                val = spec[key];</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>if (!hasOwnProperty.call(testObj, key)) {
   return false;
}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> testObj)) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
                <span class="hljs-keyword">if</span> (!val(testObj[key], testObj)) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            }
            <span class="hljs-keyword">while</span> (++j &lt; objLen) {
                key = parsedSpec.obj[j];
                <span class="hljs-keyword">if</span> (spec[key] !== testObj[key]) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p><code>where</code> takes a spec object and a test object and returns true if the test satisfies the spec.
Any property on the spec that is not a function is interpreted as an equality
relation. For example:</p>
<pre><code><span class="hljs-keyword">var</span> spec = {x: <span class="hljs-number">2</span>};
where(spec, {w: <span class="hljs-number">10</span>, x: <span class="hljs-number">2</span>, y: <span class="hljs-number">300</span>}); <span class="hljs-comment">// =&gt; true, x === 2</span>
where(spec, {x: <span class="hljs-number">1</span>, y: <span class="hljs-string">'moo'</span>, z: <span class="hljs-literal">true</span>}); <span class="hljs-comment">// =&gt; false, x !== 2</span>
</code></pre><p>If the spec has a property mapped to a function, then <code>where</code> evaluates the function, passing in
the test object’s value for the property in question, as well as the whole test object. For example:</p>
<pre><code><span class="hljs-keyword">var</span> spec = {x: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(val, obj)</span> </span>{ <span class="hljs-keyword">return</span>  val + obj.y &gt; <span class="hljs-number">10</span>; };
where(spec, {x: <span class="hljs-number">2</span>, y: <span class="hljs-number">7</span>}); <span class="hljs-comment">// =&gt; false</span>
where(spec, {x: <span class="hljs-number">3</span>, y: <span class="hljs-number">8</span>}); <span class="hljs-comment">// =&gt; true</span>
</code></pre><p><code>where</code> is well suited to declarativley expressing constraints for other functions, e.g., <code>filter</code>:</p>
<pre><code><span class="hljs-keyword">var</span> xs = [{x: <span class="hljs-number">2</span>, y: <span class="hljs-number">1</span>}, {x: <span class="hljs-number">10</span>, y: <span class="hljs-number">2</span>},
          {x: <span class="hljs-number">8</span>, y: <span class="hljs-number">3</span>}, {x: <span class="hljs-number">10</span>, y: <span class="hljs-number">4</span>}];
<span class="hljs-keyword">var</span> fxs = filter(where({x: <span class="hljs-number">10</span>}), xs);
<span class="hljs-comment">// fxs ==&gt; [{x: 10, y: 2}, {x: 10, y: 4}]</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.where = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">where</span><span class="hljs-params">(spec, testObj)</span> </span>{
            <span class="hljs-keyword">var</span> parsedSpec = R.partition(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(key)</span> </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> spec[key] === <span class="hljs-string">"function"</span> ? <span class="hljs-string">"fn"</span> : <span class="hljs-string">"obj"</span>;
                }, keys(spec)
            );
            <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">arguments</span>.length) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">throw</span> NO_ARGS_EXCEPTION;
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(testObj)</span> </span>{
                        <span class="hljs-keyword">return</span> satisfiesSpec(spec, parsedSpec, testObj);
                    };
            }
            <span class="hljs-keyword">return</span> satisfiesSpec(spec, parsedSpec, testObj);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <h2 id="miscellaneous-functions">Miscellaneous Functions</h2>

            </div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>A few functions in need of a good home.</p>

            </div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>Expose the functions from ramda as properties on another object.  If the passed-in object is the
global object, or the passed-in object is “falsy”, then the ramda functions become global functions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.installTo = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(obj)</span> </span>{
            <span class="hljs-keyword">return</span> extend(obj || global, R);
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>A function that always returns <code>0</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.alwaysZero = always(<span class="hljs-number">0</span>);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>A function that always returns <code>false</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.alwaysFalse = always(<span class="hljs-literal">false</span>);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>A function that always returns <code>true</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.alwaysTrue = always(<span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <h2 id="logic-functions">Logic Functions</h2>

            </div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>These functions are very simple wrappers around the built-in logical operators, useful in building up
more complex functional forms.</p>

            </div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>A function wrapping calls to the two functions in an <code>&amp;&amp;</code> operation, returning <code>true</code> or <code>false</code>.  Note that
this is short-circuited, meaning that the second function will not be invoked if the first returns a false-y
value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.and = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(f, g)</span> </span>{
           <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_and</span><span class="hljs-params">(g)</span> </span>{
               <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{<span class="hljs-keyword">return</span> !!(f.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>) &amp;&amp; g.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>));};
           }
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? _and : _and(g);
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p>A function wrapping calls to the two functions in an <code>||</code> operation, returning <code>true</code> or <code>false</code>.  Note that
this is short-circuited, meaning that the second function will not be invoked if the first returns a truth-y
value. (Note also that at least Oliver Twist can pronounce this one…)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.or = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(f, g)</span> </span>{ <span class="hljs-comment">// TODO: arity?</span>
           <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_or</span><span class="hljs-params">(g)</span> </span>{
               <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{<span class="hljs-keyword">return</span> !!(f.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>) || g.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>));};
           }
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? _or : _or(g);
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>A function wrapping a call to the given function in a <code>!</code> operation.  It will return <code>true</code> when the
underlying function would return a false-y value, and <code>false</code> when it would return a truth-y one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> not = R.not = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(f)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{<span class="hljs-keyword">return</span> !f.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);};
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>Create a predicate wrapper which will call a pick function (all/any) for each predicate</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> predicateWrap = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(predPicker)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(preds <span class="hljs-comment">/* , args */</span>)</span> </span>{
                <span class="hljs-keyword">var</span> predIterator = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;
                    <span class="hljs-keyword">return</span> predPicker(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(predicate)</span> </span>{
                        <span class="hljs-keyword">return</span> predicate.apply(<span class="hljs-literal">null</span>, args);
                    }, preds);
                };
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">1</span> ?</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>Call function imediately if given arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        predIterator.apply(<span class="hljs-literal">null</span>, _slice(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>)) :</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <p>Return a function which will call the predicates with the provided arguments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        arity(max(pluck(<span class="hljs-string">"length"</span>, preds)), predIterator);
            };
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <p>Given a list of predicates returns a new predicate that will be true exactly when all of them are.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.allPredicates = predicateWrap(all);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>Given a list of predicates returns a new predicate that will be true exactly when any one of them is.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.anyPredicates = predicateWrap(any);</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <h2 id="arithmetic-functions">Arithmetic Functions</h2>

            </div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <p>These functions wrap up the certain core arithmetic operators</p>

            </div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <p>Adds two numbers.  Automatic curried:</p>
<pre><code><span class="hljs-keyword">var</span> add7 = add(<span class="hljs-number">7</span>);
add7(<span class="hljs-number">10</span>); <span class="hljs-comment">// =&gt; 17</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> add = R.add = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> a + b; } :  a + b;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>Multiplies two numbers.  Automatically curried:</p>
<pre><code><span class="hljs-keyword">var</span> mult3 = multiply(<span class="hljs-number">3</span>);
mult3(<span class="hljs-number">7</span>); <span class="hljs-comment">// =&gt; 21</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> multiply = R.multiply = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> a * b; } :  a * b;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p>Subtracts the second parameter from the first.  This is automatically curried, and while at times the curried
version might be useful, often the curried version of <code>subtractN</code> might be what’s wanted.</p>
<pre><code><span class="hljs-keyword">var</span> complementaryAngle = subtract(<span class="hljs-number">90</span>);
complementaryAngle(<span class="hljs-number">30</span>) ; <span class="hljs-comment">// =&gt; 60</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> subtract = R.subtract = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> a - b; } :  a - b;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <p>Reversed version of <code>subtract</code>, where first parameter is subtracted from the second.  The curried version of
this one might me more useful than that of <code>subtract</code>.  For instance:</p>
<pre><code><span class="hljs-keyword">var</span> decrement = subtractN(<span class="hljs-number">1</span>);
decrement(<span class="hljs-number">10</span>); <span class="hljs-comment">// =&gt; 9;</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.subtractN = flip(subtract);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p>Divides the first parameter by the second.  This is automatically curried, and while at times the curried
version might be useful, often the curried version of <code>divideBy</code> might be what’s wanted.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> divide = R.divide = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> a / b; } :  a / b;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p>Reversed version of <code>divide</code>, where the second parameter is divided by the first.  The curried version of
this one might be more useful than that of <code>divide</code>.  For instance:</p>
<pre><code><span class="hljs-keyword">var</span> half = divideBy(<span class="hljs-number">2</span>);
half(<span class="hljs-number">42</span>); <span class="hljs-comment">// =&gt; 21</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.divideBy = flip(divide);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>Divides the second parameter by the first and returns the remainder.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> modulo = R.modulo = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> a % b; } :  a % b;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p>Reversed version of <code>modulo</code>, where the second parameter is divided by the first.  The curried version of
this one might be more useful than that of <code>modulo</code>.  For instance:</p>
<pre><code><span class="hljs-keyword">var</span> isOdd = moduloBy(<span class="hljs-number">2</span>);
isOdd(<span class="hljs-number">42</span>); <span class="hljs-comment">// =&gt; 0</span>
isOdd(<span class="hljs-number">21</span>); <span class="hljs-comment">// =&gt; 1</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.moduloBy = flip(modulo);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <p>Adds together all the elements of a list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.sum = foldl(add, <span class="hljs-number">0</span>);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <p>Multiplies together all the elements of a list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.product = foldl(multiply, <span class="hljs-number">1</span>);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p>Returns true if the first parameter is less than the second.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.lt = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> a &lt; b; } :  a &lt; b;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <p>Returns true if the first parameter is less than or equal to the second.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.lte = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> a &lt;= b; } :  a &lt;= b;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <p>Returns true if the first parameter is greater than the second.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.gt = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> a &gt; b; } :  a &gt; b;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <p>Returns true if the first parameter is greater than or equal to the second.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.gte = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(b)</span> </span>{ <span class="hljs-keyword">return</span> a &gt;= b; } :  a &gt;= b;
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>Determines the largest of a list of numbers (or elements that can be cast to numbers)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> max = R.max = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(list)</span> </span>{
            <span class="hljs-keyword">return</span> foldl(binary(<span class="hljs-built_in">Math</span>.max), -<span class="hljs-literal">Infinity</span>, list);
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <p>Determines the largest of a list of items as determined by pairwise comparisons from the supplied comparator</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.maxWith = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(keyFn, list)</span> </span>{
            <span class="hljs-keyword">if</span> (!(list &amp;&amp; list.length &gt; <span class="hljs-number">0</span>)) {
               <span class="hljs-keyword">return</span> undef;
            }
            <span class="hljs-keyword">var</span> idx = <span class="hljs-number">0</span>, winner = list[idx], max = keyFn(winner), testKey;
            <span class="hljs-keyword">while</span> (++idx &lt; list.length) {
                testKey = keyFn(list[idx]);
                <span class="hljs-keyword">if</span> (testKey &gt; max) {
                    max = testKey;
                    winner = list[idx];
                }
            }
            <span class="hljs-keyword">return</span> winner;
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p>TODO: combine this with maxWith?</p>

            </div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>
              <p>Determines the smallest of a list of items as determined by pairwise comparisons from the supplied comparator</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.minWith = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(keyFn, list)</span> </span>{
            <span class="hljs-keyword">if</span> (!(list &amp;&amp; list.length &gt; <span class="hljs-number">0</span>)) {
                <span class="hljs-keyword">return</span> undef;
            }
            <span class="hljs-keyword">var</span> idx = <span class="hljs-number">0</span>, winner = list[idx], min = keyFn(list[idx]), testKey;
            <span class="hljs-keyword">while</span> (++idx &lt; list.length) {
                testKey = keyFn(list[idx]);
                <span class="hljs-keyword">if</span> (testKey &lt; min) {
                    min = testKey;
                    winner = list[idx];
                }
            }
            <span class="hljs-keyword">return</span> winner;
        });


        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-123">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <p>Determines the smallest of a list of numbers (or elements that can be cast to numbers)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.min = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(list)</span> </span>{
            <span class="hljs-keyword">return</span> foldl(binary(<span class="hljs-built_in">Math</span>.min), <span class="hljs-literal">Infinity</span>, list);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-124">&#182;</a>
              </div>
              <h2 id="string-functions">String Functions</h2>

            </div>
            
        </li>
        
        
        <li id="section-125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-125">&#182;</a>
              </div>
              <p>Much of the String.prototype API exposed as simple functions.</p>

            </div>
            
        </li>
        
        
        <li id="section-126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-126">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-127">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-128">&#182;</a>
              </div>
              <p>A substring of a String:</p>
<pre><code>substring(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-string">"abcdefghijklm"</span>); <span class="hljs-comment">//=&gt; "cde"</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> substring = R.substring = invoker(<span class="hljs-string">"substring"</span>, <span class="hljs-built_in">String</span>.prototype);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-129">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-129">&#182;</a>
              </div>
              <p>The trailing substring of a String starting with the nth character:</p>
<pre><code>substringFrom(<span class="hljs-number">8</span>, <span class="hljs-string">"abcdefghijklm"</span>); <span class="hljs-comment">//=&gt; "ijklm"</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.substringFrom = flip(substring)(undef);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-130">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-130">&#182;</a>
              </div>
              <p>The leading substring of a String ending before the nth character:</p>
<pre><code>substringTo(<span class="hljs-number">8</span>, <span class="hljs-string">"abcdefghijklm"</span>); <span class="hljs-comment">//=&gt; "abcdefgh"</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.substringTo = substring(<span class="hljs-number">0</span>);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-131">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-131">&#182;</a>
              </div>
              <p>The character at the nth position in a String:</p>
<pre><code>charAt(<span class="hljs-number">8</span>, <span class="hljs-string">"abcdefghijklm"</span>); <span class="hljs-comment">//=&gt; "i"</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.charAt = invoker(<span class="hljs-string">"charAt"</span>, <span class="hljs-built_in">String</span>.prototype);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-132">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-132">&#182;</a>
              </div>
              <p>The ascii code of the character at the nth position in a String:</p>
<pre><code>charCodeAt(<span class="hljs-number">8</span>, <span class="hljs-string">"abcdefghijklm"</span>); <span class="hljs-comment">//=&gt; 105</span>
<span class="hljs-comment">// (... 'a' ~ 97, 'b' ~ 98, ... 'i' ~ 105)</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.charCodeAt = invoker(<span class="hljs-string">"charCodeAt"</span>, <span class="hljs-built_in">String</span>.prototype);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-133">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-133">&#182;</a>
              </div>
              <p>Tests a regular expression agains a String</p>
<pre><code>match(<span class="hljs-regexp">/([a-z]a)/g</span>, <span class="hljs-string">"bananas"</span>); <span class="hljs-comment">//=&gt; ["ba", "na", "na"]</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.match = invoker(<span class="hljs-string">"match"</span>, <span class="hljs-built_in">String</span>.prototype);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-134">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-134">&#182;</a>
              </div>
              <p>Finds the index of a substring in a string, returning -1 if it’s not present</p>
<pre><code>strIndexOf(<span class="hljs-string">'c'</span>, <span class="hljs-string">'abcdefg) //=&gt; 2</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.strIndexOf = invoker(<span class="hljs-string">"indexOf"</span>, <span class="hljs-built_in">String</span>.prototype);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-135">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-135">&#182;</a>
              </div>
              <p>Finds the last index of a substring in a string, returning -1 if it’s not present</p>
<pre><code>strLastIndexOf(<span class="hljs-string">'a'</span>, <span class="hljs-string">'banana split'</span>) <span class="hljs-comment">//=&gt; 5</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.strLastIndexOf = invoker(<span class="hljs-string">"lastIndexOf"</span>, <span class="hljs-built_in">String</span>.prototype);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-136">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-136">&#182;</a>
              </div>
              <p>The uppercase version of a string.</p>
<pre><code>toUpperCase(<span class="hljs-string">'abc'</span>) <span class="hljs-comment">//=&gt; 'ABC'</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.toUpperCase = invoker(<span class="hljs-string">"toUpperCase"</span>, <span class="hljs-built_in">String</span>.prototype);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-137">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-137">&#182;</a>
              </div>
              <p>The lowercase version of a string.</p>
<pre><code>toLowerCase(<span class="hljs-string">'XYZ'</span>) <span class="hljs-comment">//=&gt; 'xyz'</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.toLowerCase = invoker(<span class="hljs-string">"toLowerCase"</span>, <span class="hljs-built_in">String</span>.prototype);


        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-138">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-138">&#182;</a>
              </div>
              <p>The string split into substring at the specified token</p>
<pre><code>split(<span class="hljs-string">'.'</span>, <span class="hljs-string">'a.b.c.xyz.d'</span>) <span class="hljs-comment">//=&gt;</span>
    [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'xyz'</span>, <span class="hljs-string">'d'</span>]
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.split = invoker(<span class="hljs-string">"split"</span>, <span class="hljs-built_in">String</span>.prototype, <span class="hljs-number">1</span>);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-139">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-139">&#182;</a>
              </div>
              <p>internal path function
Takes an array, paths, indicating the deep set of keys
to find. E.g.
path([‘a’, ‘b’], {a: {b: 2}}) // =&gt; 2</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">path</span><span class="hljs-params">(paths, obj)</span> </span>{
            <span class="hljs-keyword">var</span> i = -<span class="hljs-number">1</span>, length = paths.length, val;
            <span class="hljs-keyword">while</span> (obj != <span class="hljs-literal">null</span> &amp;&amp; ++i &lt; length) {
                obj = val = obj[paths[i]];
            }
            <span class="hljs-keyword">return</span> val;
        }

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-140">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-140">&#182;</a>
              </div>
              <p>Retrieve a computed path by a function, fn. Fn will be given
a string, str which it will use to compute the path
e.g. fn(“a.b”) =&gt; [“a”, “b”]
This path will be looked up on the object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.pathWith = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pathWith</span><span class="hljs-params">(fn, str, obj)</span> </span>{
            <span class="hljs-keyword">var</span> paths = fn(str) || [];
            <span class="hljs-keyword">return</span> path(paths, obj);
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-141">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-141">&#182;</a>
              </div>
              <p>Retrieve a value on an object from a deep path, str
different properties on nested objects are indicated in string
by a seperator, sep
R.pathOn(“|”, “a|b”, {a: {b: 2}}) // =&gt; 2</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.pathOn = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pathOn</span><span class="hljs-params">(sep, str, obj)</span> </span>{
            <span class="hljs-keyword">return</span> path(str.split(sep), obj);
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-142">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-142">&#182;</a>
              </div>
              <p>Retrieve a nested path on an object seperated by periods
R.path(‘a.b’], {a: {b: 2}}) // =&gt; 2</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.path = R.pathOn(<span class="hljs-string">'.'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-143">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-143">&#182;</a>
              </div>
              <h2 id="data-analysis-and-grouping-functions">Data Analysis and Grouping Functions</h2>

            </div>
            
        </li>
        
        
        <li id="section-144">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-144">&#182;</a>
              </div>
              <p>Functions performing SQL-like actions on lists of objects.  These do not have any SQL-like optimizations
performed on them, however.</p>

            </div>
            
        </li>
        
        
        <li id="section-145">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-145">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-146">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-146">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-147">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-147">&#182;</a>
              </div>
              <p>Reasonable analog to SQL <code>select</code> statement.</p>
<pre><code><span class="hljs-keyword">var</span> kids = [
    {name: <span class="hljs-string">'Abby'</span>, age: <span class="hljs-number">7</span>, hair: <span class="hljs-string">'blond'</span>, grade: <span class="hljs-number">2</span>},
    {name: <span class="hljs-string">'Fred'</span>, age: <span class="hljs-number">12</span>, hair: <span class="hljs-string">'brown'</span>, grade: <span class="hljs-number">7</span>}
];
project([<span class="hljs-string">'name'</span>, <span class="hljs-string">'grade'</span>], kids);
<span class="hljs-comment">//=&gt; [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.project = useWith(map, R.pickAll, identity); <span class="hljs-comment">// passing `identity` gives correct arity</span>

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-148">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-148">&#182;</a>
              </div>
              <p>Determines whether the given property of an object has a specific value
Most likely used to filter a list:</p>
<pre><code><span class="hljs-keyword">var</span> kids = [
  {name: <span class="hljs-string">'Abby'</span>, age: <span class="hljs-number">7</span>, hair: <span class="hljs-string">'blond'</span>},
  {name: <span class="hljs-string">'Fred'</span>, age: <span class="hljs-number">12</span>, hair: <span class="hljs-string">'brown'</span>},
  {name: <span class="hljs-string">'Rusty'</span>, age: <span class="hljs-number">10</span>, hair: <span class="hljs-string">'brown'</span>},
  {name: <span class="hljs-string">'Alois'</span>, age: <span class="hljs-number">15</span>, disposition: <span class="hljs-string">'surly'</span>}
];
filter(propEq(<span class="hljs-string">"hair"</span>, <span class="hljs-string">"brown"</span>), kids);
<span class="hljs-comment">//=&gt; Fred and Rusty</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>        R.propEq = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, val, obj)</span> </span>{
            <span class="hljs-keyword">var</span> f1 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">propEqCurried1</span><span class="hljs-params">(val, obj)</span> </span>{
                <span class="hljs-keyword">var</span> f2 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">propEqCurried2</span><span class="hljs-params">(obj)</span> </span>{
                    <span class="hljs-keyword">return</span> obj[name] === val;
                };
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? f2 : f2(obj);
            };
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? f1 :
                <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">3</span> ? f1(val) :
                    f1(val, obj);
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-149">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-149">&#182;</a>
              </div>
              <p>Combines two lists into a set (i.e. no duplicates) composed of the elements of each list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.union = compose(uniq, R.concat);

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-150">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-150">&#182;</a>
              </div>
              <p>Combines two lists into a set (i.e. no duplicates) composed of the elements of each list.  Duplication is
determined according to the value returned by applying the supplied predicate to two list elements.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.unionWith = curry3(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(pred, list1, list2)</span> </span>{
            <span class="hljs-keyword">return</span> uniqWith(pred, concat(list1, list2));
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-151">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-151">&#182;</a>
              </div>
              <p>Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.difference = curry2(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(first, second)</span> </span>{
            <span class="hljs-keyword">return</span> uniq(reject(flip(contains)(second), first));
        });

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-152">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-152">&#182;</a>
              </div>
              <p>Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.
Duplication is determined according to the value returned by applying the supplied predicate to two list
elements.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.differenceWith = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(pred, first, second)</span> </span>{
            <span class="hljs-keyword">var</span> f1 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">differenceWithCurried1</span><span class="hljs-params">(first, second)</span> </span>{
                <span class="hljs-keyword">var</span> f2 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">differenceWithCurried2</span><span class="hljs-params">(second)</span> </span>{
                    <span class="hljs-keyword">return</span> uniqWith(pred)(reject(flip(R.containsWith(pred))(second), first));
                };
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? f2 : f2(second);
            };
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? f1 :
                <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">3</span> ? f1(first) :
                    f1(first, second);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-153">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-153">&#182;</a>
              </div>
              <p>Combines two lists into a set (i.e. no duplicates) composed of those elements common to both lists.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.intersection = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(list1, list2)</span> </span>{
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_intersection</span><span class="hljs-params">(list2)</span> </span>{
                <span class="hljs-keyword">return</span> uniq(filter(flip(contains)(list1), list2));
            }
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? _intersection : _intersection(list2);
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-154">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-154">&#182;</a>
              </div>
              <p>Combines two lists into a set (i.e. no duplicates) composed of those elements common to both lists.
Duplication is determined according to the value returned by applying the supplied predicate to two list
elements.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.intersectionWith = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(pred, list1, list2)</span> </span>{
            <span class="hljs-keyword">var</span> f1 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">intersectionWithCurried1</span><span class="hljs-params">(list1, list2)</span> </span>{
                <span class="hljs-keyword">var</span> f2 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">intersectionWithCurried2</span><span class="hljs-params">(list2)</span> </span>{
                    <span class="hljs-keyword">var</span> results = [], idx = -<span class="hljs-number">1</span>;
                    <span class="hljs-keyword">while</span> (++idx &lt; list1.length) {
                        <span class="hljs-keyword">if</span> (containsWith(pred, list1[idx], list2)) {
                            results[results.length] = list1[idx];
                        }
                    }
                    <span class="hljs-keyword">return</span> uniqWith(pred, results);
                };
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? f2 : f2(list2);
            };
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? f1 :
                <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">3</span> ? f1(list1) :
                    f1(list1, list2);
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-155">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-155">&#182;</a>
              </div>
              <p>Creates a new list whose elements each have two properties: <code>val</code> is the value of the corresponding
item in the list supplied, and <code>key</code> is the result of applying the supplied function to that item.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> keyValue = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, list)</span> </span>{ <span class="hljs-comment">// TODO: Should this be made public?</span>
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_keyValue</span><span class="hljs-params">(list)</span> </span>{
                <span class="hljs-keyword">return</span> map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> </span>{<span class="hljs-keyword">return</span> {key: fn(item), val: item};}, list);
            }
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? _keyValue : _keyValue(list);
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-156">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-156">&#182;</a>
              </div>
              <p>Sorts the list according to a key generated by the supplied function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.sortBy = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-comment">/*
              return sort(comparator(function(a, b) {return fn(a) &lt; fn(b);}), list); // clean, but too time-inefficient
              return pluck("val", sort(comparator(function(a, b) {return a.key &lt; b.key;}), keyValue(fn, list))); // nice, but no need to clone result of keyValue call, so...
            */</span>
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_sortBy</span><span class="hljs-params">(list)</span> </span>{
                <span class="hljs-keyword">return</span> pluck(<span class="hljs-string">"val"</span>, keyValue(fn, list).sort(comparator(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{<span class="hljs-keyword">return</span> a.key &lt; b.key;})));
            }
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? _sortBy : _sortBy(list);
        };

        <span class="hljs-comment">/**
         * TODO: JSDoc-style documentation for this function
         */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-157">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-157">&#182;</a>
              </div>
              <p>Counts the elements of a list according to how many match each value of a key generated by the supplied function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        R.countBy = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(fn, list)</span> </span>{
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_countBy</span><span class="hljs-params">(list)</span> </span>{
                <span class="hljs-keyword">return</span> foldl(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(counts, obj)</span> </span>{
                    counts[obj.key] = (counts[obj.key] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">return</span> counts;
                }, {}, keyValue(fn, list));
            }
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">2</span> ? _countBy : _countBy(list);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-158">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-158">&#182;</a>
              </div>
              <p>All the functional goodness, wrapped in a nice little package, just for you!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> R;
    }());
}));</pre></div></div>
            
        </li>
        
    </ul>
  </div>
  <script src="http://cdn.jsdelivr.net/ramda/latest/ramda.min.js"></script>
</body>
</html>
